// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: myprotocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_myprotocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_myprotocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_myprotocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_myprotocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_myprotocol_2eproto;
namespace GoBang {
class Border;
struct BorderDefaultTypeInternal;
extern BorderDefaultTypeInternal _Border_default_instance_;
class ContinueGameRequest;
struct ContinueGameRequestDefaultTypeInternal;
extern ContinueGameRequestDefaultTypeInternal _ContinueGameRequest_default_instance_;
class ContinueGameResponse;
struct ContinueGameResponseDefaultTypeInternal;
extern ContinueGameResponseDefaultTypeInternal _ContinueGameResponse_default_instance_;
class CreateRoomRequest;
struct CreateRoomRequestDefaultTypeInternal;
extern CreateRoomRequestDefaultTypeInternal _CreateRoomRequest_default_instance_;
class CreateRoomResponse;
struct CreateRoomResponseDefaultTypeInternal;
extern CreateRoomResponseDefaultTypeInternal _CreateRoomResponse_default_instance_;
class GameOver;
struct GameOverDefaultTypeInternal;
extern GameOverDefaultTypeInternal _GameOver_default_instance_;
class GameStart;
struct GameStartDefaultTypeInternal;
extern GameStartDefaultTypeInternal _GameStart_default_instance_;
class JoinRoomRequest;
struct JoinRoomRequestDefaultTypeInternal;
extern JoinRoomRequestDefaultTypeInternal _JoinRoomRequest_default_instance_;
class JoinRoomResponse;
struct JoinRoomResponseDefaultTypeInternal;
extern JoinRoomResponseDefaultTypeInternal _JoinRoomResponse_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class Messg;
struct MessgDefaultTypeInternal;
extern MessgDefaultTypeInternal _Messg_default_instance_;
class NormalMatchRequest;
struct NormalMatchRequestDefaultTypeInternal;
extern NormalMatchRequestDefaultTypeInternal _NormalMatchRequest_default_instance_;
class NormalMatchResponse;
struct NormalMatchResponseDefaultTypeInternal;
extern NormalMatchResponseDefaultTypeInternal _NormalMatchResponse_default_instance_;
class Piece;
struct PieceDefaultTypeInternal;
extern PieceDefaultTypeInternal _Piece_default_instance_;
class Player;
struct PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class QuitRoomRequest;
struct QuitRoomRequestDefaultTypeInternal;
extern QuitRoomRequestDefaultTypeInternal _QuitRoomRequest_default_instance_;
class QuitRoomResponse;
struct QuitRoomResponseDefaultTypeInternal;
extern QuitRoomResponseDefaultTypeInternal _QuitRoomResponse_default_instance_;
class RankListRequest;
struct RankListRequestDefaultTypeInternal;
extern RankListRequestDefaultTypeInternal _RankListRequest_default_instance_;
class RankListResponse;
struct RankListResponseDefaultTypeInternal;
extern RankListResponseDefaultTypeInternal _RankListResponse_default_instance_;
class RankMatchRequest;
struct RankMatchRequestDefaultTypeInternal;
extern RankMatchRequestDefaultTypeInternal _RankMatchRequest_default_instance_;
class RankMatchResponse;
struct RankMatchResponseDefaultTypeInternal;
extern RankMatchResponseDefaultTypeInternal _RankMatchResponse_default_instance_;
class RegisterRequest;
struct RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterResponse;
struct RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class SetPieceRequest;
struct SetPieceRequestDefaultTypeInternal;
extern SetPieceRequestDefaultTypeInternal _SetPieceRequest_default_instance_;
class SetPieceResponse;
struct SetPieceResponseDefaultTypeInternal;
extern SetPieceResponseDefaultTypeInternal _SetPieceResponse_default_instance_;
class SurrenderRequest;
struct SurrenderRequestDefaultTypeInternal;
extern SurrenderRequestDefaultTypeInternal _SurrenderRequest_default_instance_;
class TieRequest;
struct TieRequestDefaultTypeInternal;
extern TieRequestDefaultTypeInternal _TieRequest_default_instance_;
class TieResponse;
struct TieResponseDefaultTypeInternal;
extern TieResponseDefaultTypeInternal _TieResponse_default_instance_;
class UndoRequest;
struct UndoRequestDefaultTypeInternal;
extern UndoRequestDefaultTypeInternal _UndoRequest_default_instance_;
class UndoResponse;
struct UndoResponseDefaultTypeInternal;
extern UndoResponseDefaultTypeInternal _UndoResponse_default_instance_;
class goBangRequest;
struct goBangRequestDefaultTypeInternal;
extern goBangRequestDefaultTypeInternal _goBangRequest_default_instance_;
class goBangResponse;
struct goBangResponseDefaultTypeInternal;
extern goBangResponseDefaultTypeInternal _goBangResponse_default_instance_;
}  // namespace GoBang
PROTOBUF_NAMESPACE_OPEN
template<> ::GoBang::Border* Arena::CreateMaybeMessage<::GoBang::Border>(Arena*);
template<> ::GoBang::ContinueGameRequest* Arena::CreateMaybeMessage<::GoBang::ContinueGameRequest>(Arena*);
template<> ::GoBang::ContinueGameResponse* Arena::CreateMaybeMessage<::GoBang::ContinueGameResponse>(Arena*);
template<> ::GoBang::CreateRoomRequest* Arena::CreateMaybeMessage<::GoBang::CreateRoomRequest>(Arena*);
template<> ::GoBang::CreateRoomResponse* Arena::CreateMaybeMessage<::GoBang::CreateRoomResponse>(Arena*);
template<> ::GoBang::GameOver* Arena::CreateMaybeMessage<::GoBang::GameOver>(Arena*);
template<> ::GoBang::GameStart* Arena::CreateMaybeMessage<::GoBang::GameStart>(Arena*);
template<> ::GoBang::JoinRoomRequest* Arena::CreateMaybeMessage<::GoBang::JoinRoomRequest>(Arena*);
template<> ::GoBang::JoinRoomResponse* Arena::CreateMaybeMessage<::GoBang::JoinRoomResponse>(Arena*);
template<> ::GoBang::LoginRequest* Arena::CreateMaybeMessage<::GoBang::LoginRequest>(Arena*);
template<> ::GoBang::LoginResponse* Arena::CreateMaybeMessage<::GoBang::LoginResponse>(Arena*);
template<> ::GoBang::Messg* Arena::CreateMaybeMessage<::GoBang::Messg>(Arena*);
template<> ::GoBang::NormalMatchRequest* Arena::CreateMaybeMessage<::GoBang::NormalMatchRequest>(Arena*);
template<> ::GoBang::NormalMatchResponse* Arena::CreateMaybeMessage<::GoBang::NormalMatchResponse>(Arena*);
template<> ::GoBang::Piece* Arena::CreateMaybeMessage<::GoBang::Piece>(Arena*);
template<> ::GoBang::Player* Arena::CreateMaybeMessage<::GoBang::Player>(Arena*);
template<> ::GoBang::QuitRoomRequest* Arena::CreateMaybeMessage<::GoBang::QuitRoomRequest>(Arena*);
template<> ::GoBang::QuitRoomResponse* Arena::CreateMaybeMessage<::GoBang::QuitRoomResponse>(Arena*);
template<> ::GoBang::RankListRequest* Arena::CreateMaybeMessage<::GoBang::RankListRequest>(Arena*);
template<> ::GoBang::RankListResponse* Arena::CreateMaybeMessage<::GoBang::RankListResponse>(Arena*);
template<> ::GoBang::RankMatchRequest* Arena::CreateMaybeMessage<::GoBang::RankMatchRequest>(Arena*);
template<> ::GoBang::RankMatchResponse* Arena::CreateMaybeMessage<::GoBang::RankMatchResponse>(Arena*);
template<> ::GoBang::RegisterRequest* Arena::CreateMaybeMessage<::GoBang::RegisterRequest>(Arena*);
template<> ::GoBang::RegisterResponse* Arena::CreateMaybeMessage<::GoBang::RegisterResponse>(Arena*);
template<> ::GoBang::SetPieceRequest* Arena::CreateMaybeMessage<::GoBang::SetPieceRequest>(Arena*);
template<> ::GoBang::SetPieceResponse* Arena::CreateMaybeMessage<::GoBang::SetPieceResponse>(Arena*);
template<> ::GoBang::SurrenderRequest* Arena::CreateMaybeMessage<::GoBang::SurrenderRequest>(Arena*);
template<> ::GoBang::TieRequest* Arena::CreateMaybeMessage<::GoBang::TieRequest>(Arena*);
template<> ::GoBang::TieResponse* Arena::CreateMaybeMessage<::GoBang::TieResponse>(Arena*);
template<> ::GoBang::UndoRequest* Arena::CreateMaybeMessage<::GoBang::UndoRequest>(Arena*);
template<> ::GoBang::UndoResponse* Arena::CreateMaybeMessage<::GoBang::UndoResponse>(Arena*);
template<> ::GoBang::goBangRequest* Arena::CreateMaybeMessage<::GoBang::goBangRequest>(Arena*);
template<> ::GoBang::goBangResponse* Arena::CreateMaybeMessage<::GoBang::goBangResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace GoBang {

enum TYPE : int {
  LOGIN = 0,
  REGISTER = 1,
  RANK_LIST = 2,
  NORMAL_MATCH = 3,
  RANK_MATCH = 4,
  CREATE_ROOM = 5,
  JOIN_ROOM = 6,
  SET_PIECE = 7,
  UNDO = 8,
  TIE = 9,
  SURRENDER = 10,
  MSG = 11,
  CONTINUE_GAME = 12,
  QUIT_ROOM = 13,
  GAMESTART = 15,
  GAMEOVER = 14,
  TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TYPE_IsValid(int value);
constexpr TYPE TYPE_MIN = LOGIN;
constexpr TYPE TYPE_MAX = GAMESTART;
constexpr int TYPE_ARRAYSIZE = TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TYPE_descriptor();
template<typename T>
inline const std::string& TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TYPE_descriptor(), enum_t_value);
}
inline bool TYPE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TYPE>(
    TYPE_descriptor(), name, value);
}
enum PieceColor : int {
  NO_PIECE = 0,
  BLACK = 2,
  WHITE = 3,
  PieceColor_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PieceColor_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PieceColor_IsValid(int value);
constexpr PieceColor PieceColor_MIN = NO_PIECE;
constexpr PieceColor PieceColor_MAX = WHITE;
constexpr int PieceColor_ARRAYSIZE = PieceColor_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PieceColor_descriptor();
template<typename T>
inline const std::string& PieceColor_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PieceColor>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PieceColor_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PieceColor_descriptor(), enum_t_value);
}
inline bool PieceColor_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PieceColor* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PieceColor>(
    PieceColor_descriptor(), name, value);
}
// ===================================================================

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit PROTOBUF_CONSTEXPR LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRequest& from) {
    LoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPasswdFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string passwd = 2;
  void clear_passwd();
  const std::string& passwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passwd();
  PROTOBUF_NODISCARD std::string* release_passwd();
  void set_allocated_passwd(std::string* passwd);
  private:
  const std::string& _internal_passwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passwd(const std::string& value);
  std::string* _internal_mutable_passwd();
  public:

  // @@protoc_insertion_point(class_scope:GoBang.LoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passwd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  ~LoginResponse() override;
  explicit PROTOBUF_CONSTEXPR LoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginResponse& from) {
    LoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.LoginResponse";
  }
  protected:
  explicit LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kUidFieldNumber = 3,
    kSuccessFieldNumber = 1,
    kPointsFieldNumber = 4,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string uid = 3;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 points = 4;
  void clear_points();
  int32_t points() const;
  void set_points(int32_t value);
  private:
  int32_t _internal_points() const;
  void _internal_set_points(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GoBang.LoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    bool success_;
    int32_t points_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class RegisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.RegisterRequest) */ {
 public:
  inline RegisterRequest() : RegisterRequest(nullptr) {}
  ~RegisterRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterRequest(const RegisterRequest& from);
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterRequest& from) {
    RegisterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.RegisterRequest";
  }
  protected:
  explicit RegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPasswdFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string passwd = 2;
  void clear_passwd();
  const std::string& passwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passwd();
  PROTOBUF_NODISCARD std::string* release_passwd();
  void set_allocated_passwd(std::string* passwd);
  private:
  const std::string& _internal_passwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passwd(const std::string& value);
  std::string* _internal_mutable_passwd();
  public:

  // @@protoc_insertion_point(class_scope:GoBang.RegisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passwd_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class RegisterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.RegisterResponse) */ {
 public:
  inline RegisterResponse() : RegisterResponse(nullptr) {}
  ~RegisterResponse() override;
  explicit PROTOBUF_CONSTEXPR RegisterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterResponse(const RegisterResponse& from);
  RegisterResponse(RegisterResponse&& from) noexcept
    : RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
               &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RegisterResponse& a, RegisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterResponse& from) {
    RegisterResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.RegisterResponse";
  }
  protected:
  explicit RegisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:GoBang.RegisterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class RankListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.RankListRequest) */ {
 public:
  inline RankListRequest() : RankListRequest(nullptr) {}
  ~RankListRequest() override;
  explicit PROTOBUF_CONSTEXPR RankListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RankListRequest(const RankListRequest& from);
  RankListRequest(RankListRequest&& from) noexcept
    : RankListRequest() {
    *this = ::std::move(from);
  }

  inline RankListRequest& operator=(const RankListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RankListRequest& operator=(RankListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RankListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RankListRequest* internal_default_instance() {
    return reinterpret_cast<const RankListRequest*>(
               &_RankListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RankListRequest& a, RankListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RankListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RankListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RankListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RankListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RankListRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RankListRequest& from) {
    RankListRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RankListRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.RankListRequest";
  }
  protected:
  explicit RankListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kCntFieldNumber = 2,
  };
  // int32 start = 1;
  void clear_start();
  int32_t start() const;
  void set_start(int32_t value);
  private:
  int32_t _internal_start() const;
  void _internal_set_start(int32_t value);
  public:

  // int32 cnt = 2;
  void clear_cnt();
  int32_t cnt() const;
  void set_cnt(int32_t value);
  private:
  int32_t _internal_cnt() const;
  void _internal_set_cnt(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GoBang.RankListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t start_;
    int32_t cnt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Player final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.Player) */ {
 public:
  inline Player() : Player(nullptr) {}
  ~Player() override;
  explicit PROTOBUF_CONSTEXPR Player(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Player(const Player& from);
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }
  inline void Swap(Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Player& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Player& from) {
    Player::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.Player";
  }
  protected:
  explicit Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kNameFieldNumber = 2,
    kPointsFieldNumber = 3,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 points = 3;
  void clear_points();
  int32_t points() const;
  void set_points(int32_t value);
  private:
  int32_t _internal_points() const;
  void _internal_set_points(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GoBang.Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t points_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class RankListResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.RankListResponse) */ {
 public:
  inline RankListResponse() : RankListResponse(nullptr) {}
  ~RankListResponse() override;
  explicit PROTOBUF_CONSTEXPR RankListResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RankListResponse(const RankListResponse& from);
  RankListResponse(RankListResponse&& from) noexcept
    : RankListResponse() {
    *this = ::std::move(from);
  }

  inline RankListResponse& operator=(const RankListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RankListResponse& operator=(RankListResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RankListResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RankListResponse* internal_default_instance() {
    return reinterpret_cast<const RankListResponse*>(
               &_RankListResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RankListResponse& a, RankListResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RankListResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RankListResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RankListResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RankListResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RankListResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RankListResponse& from) {
    RankListResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RankListResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.RankListResponse";
  }
  protected:
  explicit RankListResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 3,
    kMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // repeated .GoBang.Player list = 3;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::GoBang::Player* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GoBang::Player >*
      mutable_list();
  private:
  const ::GoBang::Player& _internal_list(int index) const;
  ::GoBang::Player* _internal_add_list();
  public:
  const ::GoBang::Player& list(int index) const;
  ::GoBang::Player* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GoBang::Player >&
      list() const;

  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:GoBang.RankListResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GoBang::Player > list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class NormalMatchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.NormalMatchRequest) */ {
 public:
  inline NormalMatchRequest() : NormalMatchRequest(nullptr) {}
  ~NormalMatchRequest() override;
  explicit PROTOBUF_CONSTEXPR NormalMatchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NormalMatchRequest(const NormalMatchRequest& from);
  NormalMatchRequest(NormalMatchRequest&& from) noexcept
    : NormalMatchRequest() {
    *this = ::std::move(from);
  }

  inline NormalMatchRequest& operator=(const NormalMatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NormalMatchRequest& operator=(NormalMatchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NormalMatchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NormalMatchRequest* internal_default_instance() {
    return reinterpret_cast<const NormalMatchRequest*>(
               &_NormalMatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NormalMatchRequest& a, NormalMatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NormalMatchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NormalMatchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NormalMatchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NormalMatchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NormalMatchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NormalMatchRequest& from) {
    NormalMatchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NormalMatchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.NormalMatchRequest";
  }
  protected:
  explicit NormalMatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // @@protoc_insertion_point(class_scope:GoBang.NormalMatchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class NormalMatchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.NormalMatchResponse) */ {
 public:
  inline NormalMatchResponse() : NormalMatchResponse(nullptr) {}
  ~NormalMatchResponse() override;
  explicit PROTOBUF_CONSTEXPR NormalMatchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NormalMatchResponse(const NormalMatchResponse& from);
  NormalMatchResponse(NormalMatchResponse&& from) noexcept
    : NormalMatchResponse() {
    *this = ::std::move(from);
  }

  inline NormalMatchResponse& operator=(const NormalMatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NormalMatchResponse& operator=(NormalMatchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NormalMatchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NormalMatchResponse* internal_default_instance() {
    return reinterpret_cast<const NormalMatchResponse*>(
               &_NormalMatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NormalMatchResponse& a, NormalMatchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NormalMatchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NormalMatchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NormalMatchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NormalMatchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NormalMatchResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NormalMatchResponse& from) {
    NormalMatchResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NormalMatchResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.NormalMatchResponse";
  }
  protected:
  explicit NormalMatchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kRidFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string rid = 3;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:GoBang.NormalMatchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class RankMatchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.RankMatchRequest) */ {
 public:
  inline RankMatchRequest() : RankMatchRequest(nullptr) {}
  ~RankMatchRequest() override;
  explicit PROTOBUF_CONSTEXPR RankMatchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RankMatchRequest(const RankMatchRequest& from);
  RankMatchRequest(RankMatchRequest&& from) noexcept
    : RankMatchRequest() {
    *this = ::std::move(from);
  }

  inline RankMatchRequest& operator=(const RankMatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RankMatchRequest& operator=(RankMatchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RankMatchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RankMatchRequest* internal_default_instance() {
    return reinterpret_cast<const RankMatchRequest*>(
               &_RankMatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RankMatchRequest& a, RankMatchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RankMatchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RankMatchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RankMatchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RankMatchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RankMatchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RankMatchRequest& from) {
    RankMatchRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RankMatchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.RankMatchRequest";
  }
  protected:
  explicit RankMatchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // @@protoc_insertion_point(class_scope:GoBang.RankMatchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class RankMatchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.RankMatchResponse) */ {
 public:
  inline RankMatchResponse() : RankMatchResponse(nullptr) {}
  ~RankMatchResponse() override;
  explicit PROTOBUF_CONSTEXPR RankMatchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RankMatchResponse(const RankMatchResponse& from);
  RankMatchResponse(RankMatchResponse&& from) noexcept
    : RankMatchResponse() {
    *this = ::std::move(from);
  }

  inline RankMatchResponse& operator=(const RankMatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RankMatchResponse& operator=(RankMatchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RankMatchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RankMatchResponse* internal_default_instance() {
    return reinterpret_cast<const RankMatchResponse*>(
               &_RankMatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RankMatchResponse& a, RankMatchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RankMatchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RankMatchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RankMatchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RankMatchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RankMatchResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RankMatchResponse& from) {
    RankMatchResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RankMatchResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.RankMatchResponse";
  }
  protected:
  explicit RankMatchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kRidFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string rid = 3;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:GoBang.RankMatchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class CreateRoomRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.CreateRoomRequest) */ {
 public:
  inline CreateRoomRequest() : CreateRoomRequest(nullptr) {}
  ~CreateRoomRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateRoomRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRoomRequest(const CreateRoomRequest& from);
  CreateRoomRequest(CreateRoomRequest&& from) noexcept
    : CreateRoomRequest() {
    *this = ::std::move(from);
  }

  inline CreateRoomRequest& operator=(const CreateRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRoomRequest& operator=(CreateRoomRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRoomRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRoomRequest* internal_default_instance() {
    return reinterpret_cast<const CreateRoomRequest*>(
               &_CreateRoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CreateRoomRequest& a, CreateRoomRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRoomRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRoomRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRoomRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRoomRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRoomRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateRoomRequest& from) {
    CreateRoomRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRoomRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.CreateRoomRequest";
  }
  protected:
  explicit CreateRoomRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // @@protoc_insertion_point(class_scope:GoBang.CreateRoomRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class CreateRoomResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.CreateRoomResponse) */ {
 public:
  inline CreateRoomResponse() : CreateRoomResponse(nullptr) {}
  ~CreateRoomResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateRoomResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateRoomResponse(const CreateRoomResponse& from);
  CreateRoomResponse(CreateRoomResponse&& from) noexcept
    : CreateRoomResponse() {
    *this = ::std::move(from);
  }

  inline CreateRoomResponse& operator=(const CreateRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRoomResponse& operator=(CreateRoomResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateRoomResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateRoomResponse* internal_default_instance() {
    return reinterpret_cast<const CreateRoomResponse*>(
               &_CreateRoomResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CreateRoomResponse& a, CreateRoomResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRoomResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateRoomResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateRoomResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateRoomResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateRoomResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateRoomResponse& from) {
    CreateRoomResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRoomResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.CreateRoomResponse";
  }
  protected:
  explicit CreateRoomResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kRidFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string rid = 3;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:GoBang.CreateRoomResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class JoinRoomRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.JoinRoomRequest) */ {
 public:
  inline JoinRoomRequest() : JoinRoomRequest(nullptr) {}
  ~JoinRoomRequest() override;
  explicit PROTOBUF_CONSTEXPR JoinRoomRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinRoomRequest(const JoinRoomRequest& from);
  JoinRoomRequest(JoinRoomRequest&& from) noexcept
    : JoinRoomRequest() {
    *this = ::std::move(from);
  }

  inline JoinRoomRequest& operator=(const JoinRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinRoomRequest& operator=(JoinRoomRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinRoomRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinRoomRequest* internal_default_instance() {
    return reinterpret_cast<const JoinRoomRequest*>(
               &_JoinRoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(JoinRoomRequest& a, JoinRoomRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinRoomRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinRoomRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinRoomRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinRoomRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinRoomRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JoinRoomRequest& from) {
    JoinRoomRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinRoomRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.JoinRoomRequest";
  }
  protected:
  explicit JoinRoomRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
    kRidFieldNumber = 2,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // string rid = 2;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // @@protoc_insertion_point(class_scope:GoBang.JoinRoomRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class JoinRoomResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.JoinRoomResponse) */ {
 public:
  inline JoinRoomResponse() : JoinRoomResponse(nullptr) {}
  ~JoinRoomResponse() override;
  explicit PROTOBUF_CONSTEXPR JoinRoomResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinRoomResponse(const JoinRoomResponse& from);
  JoinRoomResponse(JoinRoomResponse&& from) noexcept
    : JoinRoomResponse() {
    *this = ::std::move(from);
  }

  inline JoinRoomResponse& operator=(const JoinRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinRoomResponse& operator=(JoinRoomResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinRoomResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinRoomResponse* internal_default_instance() {
    return reinterpret_cast<const JoinRoomResponse*>(
               &_JoinRoomResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(JoinRoomResponse& a, JoinRoomResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinRoomResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinRoomResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinRoomResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinRoomResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinRoomResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JoinRoomResponse& from) {
    JoinRoomResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinRoomResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.JoinRoomResponse";
  }
  protected:
  explicit JoinRoomResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kRidFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string rid = 3;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:GoBang.JoinRoomResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Piece final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.Piece) */ {
 public:
  inline Piece() : Piece(nullptr) {}
  ~Piece() override;
  explicit PROTOBUF_CONSTEXPR Piece(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Piece(const Piece& from);
  Piece(Piece&& from) noexcept
    : Piece() {
    *this = ::std::move(from);
  }

  inline Piece& operator=(const Piece& from) {
    CopyFrom(from);
    return *this;
  }
  inline Piece& operator=(Piece&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Piece& default_instance() {
    return *internal_default_instance();
  }
  static inline const Piece* internal_default_instance() {
    return reinterpret_cast<const Piece*>(
               &_Piece_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Piece& a, Piece& b) {
    a.Swap(&b);
  }
  inline void Swap(Piece* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Piece* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Piece* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Piece>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Piece& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Piece& from) {
    Piece::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Piece* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.Piece";
  }
  protected:
  explicit Piece(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kColorFieldNumber = 3,
  };
  // int32 x = 1;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // int32 y = 2;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // .GoBang.PieceColor color = 3;
  void clear_color();
  ::GoBang::PieceColor color() const;
  void set_color(::GoBang::PieceColor value);
  private:
  ::GoBang::PieceColor _internal_color() const;
  void _internal_set_color(::GoBang::PieceColor value);
  public:

  // @@protoc_insertion_point(class_scope:GoBang.Piece)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t x_;
    int32_t y_;
    int color_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Border final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.Border) */ {
 public:
  inline Border() : Border(nullptr) {}
  ~Border() override;
  explicit PROTOBUF_CONSTEXPR Border(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Border(const Border& from);
  Border(Border&& from) noexcept
    : Border() {
    *this = ::std::move(from);
  }

  inline Border& operator=(const Border& from) {
    CopyFrom(from);
    return *this;
  }
  inline Border& operator=(Border&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Border& default_instance() {
    return *internal_default_instance();
  }
  static inline const Border* internal_default_instance() {
    return reinterpret_cast<const Border*>(
               &_Border_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Border& a, Border& b) {
    a.Swap(&b);
  }
  inline void Swap(Border* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Border* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Border* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Border>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Border& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Border& from) {
    Border::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Border* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.Border";
  }
  protected:
  explicit Border(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRow2FieldNumber = 1,
    kRow4FieldNumber = 2,
    kRow6FieldNumber = 3,
    kRow8FieldNumber = 4,
    kRow10FieldNumber = 5,
    kRow12FieldNumber = 6,
    kRow14FieldNumber = 7,
    kRow16FieldNumber = 8,
  };
  // sfixed64 row_2 = 1;
  void clear_row_2();
  int64_t row_2() const;
  void set_row_2(int64_t value);
  private:
  int64_t _internal_row_2() const;
  void _internal_set_row_2(int64_t value);
  public:

  // sfixed64 row_4 = 2;
  void clear_row_4();
  int64_t row_4() const;
  void set_row_4(int64_t value);
  private:
  int64_t _internal_row_4() const;
  void _internal_set_row_4(int64_t value);
  public:

  // sfixed64 row_6 = 3;
  void clear_row_6();
  int64_t row_6() const;
  void set_row_6(int64_t value);
  private:
  int64_t _internal_row_6() const;
  void _internal_set_row_6(int64_t value);
  public:

  // sfixed64 row_8 = 4;
  void clear_row_8();
  int64_t row_8() const;
  void set_row_8(int64_t value);
  private:
  int64_t _internal_row_8() const;
  void _internal_set_row_8(int64_t value);
  public:

  // sfixed64 row_10 = 5;
  void clear_row_10();
  int64_t row_10() const;
  void set_row_10(int64_t value);
  private:
  int64_t _internal_row_10() const;
  void _internal_set_row_10(int64_t value);
  public:

  // sfixed64 row_12 = 6;
  void clear_row_12();
  int64_t row_12() const;
  void set_row_12(int64_t value);
  private:
  int64_t _internal_row_12() const;
  void _internal_set_row_12(int64_t value);
  public:

  // sfixed64 row_14 = 7;
  void clear_row_14();
  int64_t row_14() const;
  void set_row_14(int64_t value);
  private:
  int64_t _internal_row_14() const;
  void _internal_set_row_14(int64_t value);
  public:

  // sfixed64 row_16 = 8;
  void clear_row_16();
  int64_t row_16() const;
  void set_row_16(int64_t value);
  private:
  int64_t _internal_row_16() const;
  void _internal_set_row_16(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:GoBang.Border)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t row_2_;
    int64_t row_4_;
    int64_t row_6_;
    int64_t row_8_;
    int64_t row_10_;
    int64_t row_12_;
    int64_t row_14_;
    int64_t row_16_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class SetPieceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.SetPieceRequest) */ {
 public:
  inline SetPieceRequest() : SetPieceRequest(nullptr) {}
  ~SetPieceRequest() override;
  explicit PROTOBUF_CONSTEXPR SetPieceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPieceRequest(const SetPieceRequest& from);
  SetPieceRequest(SetPieceRequest&& from) noexcept
    : SetPieceRequest() {
    *this = ::std::move(from);
  }

  inline SetPieceRequest& operator=(const SetPieceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPieceRequest& operator=(SetPieceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPieceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPieceRequest* internal_default_instance() {
    return reinterpret_cast<const SetPieceRequest*>(
               &_SetPieceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SetPieceRequest& a, SetPieceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPieceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPieceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPieceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetPieceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetPieceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetPieceRequest& from) {
    SetPieceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPieceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.SetPieceRequest";
  }
  protected:
  explicit SetPieceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPFieldNumber = 1,
  };
  // .GoBang.Piece p = 1;
  bool has_p() const;
  private:
  bool _internal_has_p() const;
  public:
  void clear_p();
  const ::GoBang::Piece& p() const;
  PROTOBUF_NODISCARD ::GoBang::Piece* release_p();
  ::GoBang::Piece* mutable_p();
  void set_allocated_p(::GoBang::Piece* p);
  private:
  const ::GoBang::Piece& _internal_p() const;
  ::GoBang::Piece* _internal_mutable_p();
  public:
  void unsafe_arena_set_allocated_p(
      ::GoBang::Piece* p);
  ::GoBang::Piece* unsafe_arena_release_p();

  // @@protoc_insertion_point(class_scope:GoBang.SetPieceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::GoBang::Piece* p_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class SetPieceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.SetPieceResponse) */ {
 public:
  inline SetPieceResponse() : SetPieceResponse(nullptr) {}
  ~SetPieceResponse() override;
  explicit PROTOBUF_CONSTEXPR SetPieceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetPieceResponse(const SetPieceResponse& from);
  SetPieceResponse(SetPieceResponse&& from) noexcept
    : SetPieceResponse() {
    *this = ::std::move(from);
  }

  inline SetPieceResponse& operator=(const SetPieceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetPieceResponse& operator=(SetPieceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetPieceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetPieceResponse* internal_default_instance() {
    return reinterpret_cast<const SetPieceResponse*>(
               &_SetPieceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SetPieceResponse& a, SetPieceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetPieceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetPieceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetPieceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetPieceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetPieceResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetPieceResponse& from) {
    SetPieceResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPieceResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.SetPieceResponse";
  }
  protected:
  explicit SetPieceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kBFieldNumber = 3,
    kSuccessFieldNumber = 1,
    kNextFieldNumber = 4,
  };
  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // .GoBang.Border b = 3;
  bool has_b() const;
  private:
  bool _internal_has_b() const;
  public:
  void clear_b();
  const ::GoBang::Border& b() const;
  PROTOBUF_NODISCARD ::GoBang::Border* release_b();
  ::GoBang::Border* mutable_b();
  void set_allocated_b(::GoBang::Border* b);
  private:
  const ::GoBang::Border& _internal_b() const;
  ::GoBang::Border* _internal_mutable_b();
  public:
  void unsafe_arena_set_allocated_b(
      ::GoBang::Border* b);
  ::GoBang::Border* unsafe_arena_release_b();

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // .GoBang.PieceColor next = 4;
  void clear_next();
  ::GoBang::PieceColor next() const;
  void set_next(::GoBang::PieceColor value);
  private:
  ::GoBang::PieceColor _internal_next() const;
  void _internal_set_next(::GoBang::PieceColor value);
  public:

  // @@protoc_insertion_point(class_scope:GoBang.SetPieceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::GoBang::Border* b_;
    bool success_;
    int next_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class UndoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.UndoRequest) */ {
 public:
  inline UndoRequest() : UndoRequest(nullptr) {}
  ~UndoRequest() override;
  explicit PROTOBUF_CONSTEXPR UndoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UndoRequest(const UndoRequest& from);
  UndoRequest(UndoRequest&& from) noexcept
    : UndoRequest() {
    *this = ::std::move(from);
  }

  inline UndoRequest& operator=(const UndoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UndoRequest& operator=(UndoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UndoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UndoRequest* internal_default_instance() {
    return reinterpret_cast<const UndoRequest*>(
               &_UndoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UndoRequest& a, UndoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UndoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UndoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UndoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UndoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UndoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UndoRequest& from) {
    UndoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UndoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.UndoRequest";
  }
  protected:
  explicit UndoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // @@protoc_insertion_point(class_scope:GoBang.UndoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class UndoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.UndoResponse) */ {
 public:
  inline UndoResponse() : UndoResponse(nullptr) {}
  ~UndoResponse() override;
  explicit PROTOBUF_CONSTEXPR UndoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UndoResponse(const UndoResponse& from);
  UndoResponse(UndoResponse&& from) noexcept
    : UndoResponse() {
    *this = ::std::move(from);
  }

  inline UndoResponse& operator=(const UndoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UndoResponse& operator=(UndoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UndoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UndoResponse* internal_default_instance() {
    return reinterpret_cast<const UndoResponse*>(
               &_UndoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(UndoResponse& a, UndoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UndoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UndoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UndoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UndoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UndoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UndoResponse& from) {
    UndoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UndoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.UndoResponse";
  }
  protected:
  explicit UndoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:GoBang.UndoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class TieRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.TieRequest) */ {
 public:
  inline TieRequest() : TieRequest(nullptr) {}
  ~TieRequest() override;
  explicit PROTOBUF_CONSTEXPR TieRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TieRequest(const TieRequest& from);
  TieRequest(TieRequest&& from) noexcept
    : TieRequest() {
    *this = ::std::move(from);
  }

  inline TieRequest& operator=(const TieRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TieRequest& operator=(TieRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TieRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TieRequest* internal_default_instance() {
    return reinterpret_cast<const TieRequest*>(
               &_TieRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TieRequest& a, TieRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TieRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TieRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TieRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TieRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TieRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TieRequest& from) {
    TieRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TieRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.TieRequest";
  }
  protected:
  explicit TieRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // @@protoc_insertion_point(class_scope:GoBang.TieRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class TieResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.TieResponse) */ {
 public:
  inline TieResponse() : TieResponse(nullptr) {}
  ~TieResponse() override;
  explicit PROTOBUF_CONSTEXPR TieResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TieResponse(const TieResponse& from);
  TieResponse(TieResponse&& from) noexcept
    : TieResponse() {
    *this = ::std::move(from);
  }

  inline TieResponse& operator=(const TieResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TieResponse& operator=(TieResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TieResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TieResponse* internal_default_instance() {
    return reinterpret_cast<const TieResponse*>(
               &_TieResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(TieResponse& a, TieResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TieResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TieResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TieResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TieResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TieResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TieResponse& from) {
    TieResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TieResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.TieResponse";
  }
  protected:
  explicit TieResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:GoBang.TieResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class SurrenderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.SurrenderRequest) */ {
 public:
  inline SurrenderRequest() : SurrenderRequest(nullptr) {}
  ~SurrenderRequest() override;
  explicit PROTOBUF_CONSTEXPR SurrenderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SurrenderRequest(const SurrenderRequest& from);
  SurrenderRequest(SurrenderRequest&& from) noexcept
    : SurrenderRequest() {
    *this = ::std::move(from);
  }

  inline SurrenderRequest& operator=(const SurrenderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SurrenderRequest& operator=(SurrenderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SurrenderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SurrenderRequest* internal_default_instance() {
    return reinterpret_cast<const SurrenderRequest*>(
               &_SurrenderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SurrenderRequest& a, SurrenderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SurrenderRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SurrenderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SurrenderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SurrenderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SurrenderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SurrenderRequest& from) {
    SurrenderRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SurrenderRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.SurrenderRequest";
  }
  protected:
  explicit SurrenderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // @@protoc_insertion_point(class_scope:GoBang.SurrenderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Messg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.Messg) */ {
 public:
  inline Messg() : Messg(nullptr) {}
  ~Messg() override;
  explicit PROTOBUF_CONSTEXPR Messg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Messg(const Messg& from);
  Messg(Messg&& from) noexcept
    : Messg() {
    *this = ::std::move(from);
  }

  inline Messg& operator=(const Messg& from) {
    CopyFrom(from);
    return *this;
  }
  inline Messg& operator=(Messg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Messg& default_instance() {
    return *internal_default_instance();
  }
  static inline const Messg* internal_default_instance() {
    return reinterpret_cast<const Messg*>(
               &_Messg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Messg& a, Messg& b) {
    a.Swap(&b);
  }
  inline void Swap(Messg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Messg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Messg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Messg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Messg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Messg& from) {
    Messg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Messg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.Messg";
  }
  protected:
  explicit Messg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kMsgFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:GoBang.Messg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class ContinueGameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.ContinueGameRequest) */ {
 public:
  inline ContinueGameRequest() : ContinueGameRequest(nullptr) {}
  ~ContinueGameRequest() override;
  explicit PROTOBUF_CONSTEXPR ContinueGameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContinueGameRequest(const ContinueGameRequest& from);
  ContinueGameRequest(ContinueGameRequest&& from) noexcept
    : ContinueGameRequest() {
    *this = ::std::move(from);
  }

  inline ContinueGameRequest& operator=(const ContinueGameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContinueGameRequest& operator=(ContinueGameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContinueGameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContinueGameRequest* internal_default_instance() {
    return reinterpret_cast<const ContinueGameRequest*>(
               &_ContinueGameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ContinueGameRequest& a, ContinueGameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ContinueGameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContinueGameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContinueGameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContinueGameRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContinueGameRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContinueGameRequest& from) {
    ContinueGameRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContinueGameRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.ContinueGameRequest";
  }
  protected:
  explicit ContinueGameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // @@protoc_insertion_point(class_scope:GoBang.ContinueGameRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class ContinueGameResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:GoBang.ContinueGameResponse) */ {
 public:
  inline ContinueGameResponse() : ContinueGameResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ContinueGameResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContinueGameResponse(const ContinueGameResponse& from);
  ContinueGameResponse(ContinueGameResponse&& from) noexcept
    : ContinueGameResponse() {
    *this = ::std::move(from);
  }

  inline ContinueGameResponse& operator=(const ContinueGameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContinueGameResponse& operator=(ContinueGameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContinueGameResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContinueGameResponse* internal_default_instance() {
    return reinterpret_cast<const ContinueGameResponse*>(
               &_ContinueGameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ContinueGameResponse& a, ContinueGameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ContinueGameResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContinueGameResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContinueGameResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContinueGameResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ContinueGameResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ContinueGameResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.ContinueGameResponse";
  }
  protected:
  explicit ContinueGameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:GoBang.ContinueGameResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class QuitRoomRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.QuitRoomRequest) */ {
 public:
  inline QuitRoomRequest() : QuitRoomRequest(nullptr) {}
  ~QuitRoomRequest() override;
  explicit PROTOBUF_CONSTEXPR QuitRoomRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuitRoomRequest(const QuitRoomRequest& from);
  QuitRoomRequest(QuitRoomRequest&& from) noexcept
    : QuitRoomRequest() {
    *this = ::std::move(from);
  }

  inline QuitRoomRequest& operator=(const QuitRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuitRoomRequest& operator=(QuitRoomRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuitRoomRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuitRoomRequest* internal_default_instance() {
    return reinterpret_cast<const QuitRoomRequest*>(
               &_QuitRoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(QuitRoomRequest& a, QuitRoomRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QuitRoomRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuitRoomRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuitRoomRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuitRoomRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuitRoomRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuitRoomRequest& from) {
    QuitRoomRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuitRoomRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.QuitRoomRequest";
  }
  protected:
  explicit QuitRoomRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // @@protoc_insertion_point(class_scope:GoBang.QuitRoomRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class QuitRoomResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.QuitRoomResponse) */ {
 public:
  inline QuitRoomResponse() : QuitRoomResponse(nullptr) {}
  ~QuitRoomResponse() override;
  explicit PROTOBUF_CONSTEXPR QuitRoomResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuitRoomResponse(const QuitRoomResponse& from);
  QuitRoomResponse(QuitRoomResponse&& from) noexcept
    : QuitRoomResponse() {
    *this = ::std::move(from);
  }

  inline QuitRoomResponse& operator=(const QuitRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuitRoomResponse& operator=(QuitRoomResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuitRoomResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuitRoomResponse* internal_default_instance() {
    return reinterpret_cast<const QuitRoomResponse*>(
               &_QuitRoomResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(QuitRoomResponse& a, QuitRoomResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QuitRoomResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuitRoomResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuitRoomResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuitRoomResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuitRoomResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuitRoomResponse& from) {
    QuitRoomResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuitRoomResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.QuitRoomResponse";
  }
  protected:
  explicit QuitRoomResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
  };
  // string uid = 1;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // @@protoc_insertion_point(class_scope:GoBang.QuitRoomResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class GameStart final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.GameStart) */ {
 public:
  inline GameStart() : GameStart(nullptr) {}
  ~GameStart() override;
  explicit PROTOBUF_CONSTEXPR GameStart(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameStart(const GameStart& from);
  GameStart(GameStart&& from) noexcept
    : GameStart() {
    *this = ::std::move(from);
  }

  inline GameStart& operator=(const GameStart& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameStart& operator=(GameStart&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameStart& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameStart* internal_default_instance() {
    return reinterpret_cast<const GameStart*>(
               &_GameStart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(GameStart& a, GameStart& b) {
    a.Swap(&b);
  }
  inline void Swap(GameStart* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameStart* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameStart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameStart>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameStart& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameStart& from) {
    GameStart::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameStart* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.GameStart";
  }
  protected:
  explicit GameStart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompetitorNameFieldNumber = 3,
    kCompetitorIDFieldNumber = 4,
    kRidFieldNumber = 5,
    kMyColorFieldNumber = 1,
    kCompetitorColorFieldNumber = 2,
  };
  // string competitorName = 3;
  void clear_competitorname();
  const std::string& competitorname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_competitorname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_competitorname();
  PROTOBUF_NODISCARD std::string* release_competitorname();
  void set_allocated_competitorname(std::string* competitorname);
  private:
  const std::string& _internal_competitorname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_competitorname(const std::string& value);
  std::string* _internal_mutable_competitorname();
  public:

  // string competitorID = 4;
  void clear_competitorid();
  const std::string& competitorid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_competitorid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_competitorid();
  PROTOBUF_NODISCARD std::string* release_competitorid();
  void set_allocated_competitorid(std::string* competitorid);
  private:
  const std::string& _internal_competitorid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_competitorid(const std::string& value);
  std::string* _internal_mutable_competitorid();
  public:

  // string rid = 5;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // .GoBang.PieceColor myColor = 1;
  void clear_mycolor();
  ::GoBang::PieceColor mycolor() const;
  void set_mycolor(::GoBang::PieceColor value);
  private:
  ::GoBang::PieceColor _internal_mycolor() const;
  void _internal_set_mycolor(::GoBang::PieceColor value);
  public:

  // .GoBang.PieceColor competitorColor = 2;
  void clear_competitorcolor();
  ::GoBang::PieceColor competitorcolor() const;
  void set_competitorcolor(::GoBang::PieceColor value);
  private:
  ::GoBang::PieceColor _internal_competitorcolor() const;
  void _internal_set_competitorcolor(::GoBang::PieceColor value);
  public:

  // @@protoc_insertion_point(class_scope:GoBang.GameStart)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr competitorname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr competitorid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
    int mycolor_;
    int competitorcolor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class GameOver final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.GameOver) */ {
 public:
  inline GameOver() : GameOver(nullptr) {}
  ~GameOver() override;
  explicit PROTOBUF_CONSTEXPR GameOver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameOver(const GameOver& from);
  GameOver(GameOver&& from) noexcept
    : GameOver() {
    *this = ::std::move(from);
  }

  inline GameOver& operator=(const GameOver& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameOver& operator=(GameOver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameOver& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameOver* internal_default_instance() {
    return reinterpret_cast<const GameOver*>(
               &_GameOver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(GameOver& a, GameOver& b) {
    a.Swap(&b);
  }
  inline void Swap(GameOver* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameOver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameOver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameOver>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameOver& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GameOver& from) {
    GameOver::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameOver* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.GameOver";
  }
  protected:
  explicit GameOver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWinUidFieldNumber = 2,
    kIsWinFieldNumber = 1,
  };
  // string winUid = 2;
  void clear_winuid();
  const std::string& winuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_winuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_winuid();
  PROTOBUF_NODISCARD std::string* release_winuid();
  void set_allocated_winuid(std::string* winuid);
  private:
  const std::string& _internal_winuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_winuid(const std::string& value);
  std::string* _internal_mutable_winuid();
  public:

  // bool isWin = 1;
  void clear_iswin();
  bool iswin() const;
  void set_iswin(bool value);
  private:
  bool _internal_iswin() const;
  void _internal_set_iswin(bool value);
  public:

  // @@protoc_insertion_point(class_scope:GoBang.GameOver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr winuid_;
    bool iswin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class goBangRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.goBangRequest) */ {
 public:
  inline goBangRequest() : goBangRequest(nullptr) {}
  ~goBangRequest() override;
  explicit PROTOBUF_CONSTEXPR goBangRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  goBangRequest(const goBangRequest& from);
  goBangRequest(goBangRequest&& from) noexcept
    : goBangRequest() {
    *this = ::std::move(from);
  }

  inline goBangRequest& operator=(const goBangRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline goBangRequest& operator=(goBangRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const goBangRequest& default_instance() {
    return *internal_default_instance();
  }
  enum RequestCase {
    kLoginReq = 2,
    kRegisterReq = 3,
    kRankListReq = 4,
    kCreateRoomReq = 5,
    kSetPieceReq = 6,
    kUndoReq = 7,
    kUndoResp = 15,
    kTieReq = 8,
    kTieResp = 14,
    kSurrenderReq = 9,
    kMessg = 10,
    kContinueGameReq = 11,
    kQuitRoomReq = 12,
    kNormalMatchReq = 13,
    kRankMatchReq = 16,
    REQUEST_NOT_SET = 0,
  };

  static inline const goBangRequest* internal_default_instance() {
    return reinterpret_cast<const goBangRequest*>(
               &_goBangRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(goBangRequest& a, goBangRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(goBangRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(goBangRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  goBangRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<goBangRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const goBangRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const goBangRequest& from) {
    goBangRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(goBangRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.goBangRequest";
  }
  protected:
  explicit goBangRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kLoginReqFieldNumber = 2,
    kRegisterReqFieldNumber = 3,
    kRankListReqFieldNumber = 4,
    kCreateRoomReqFieldNumber = 5,
    kSetPieceReqFieldNumber = 6,
    kUndoReqFieldNumber = 7,
    kUndoRespFieldNumber = 15,
    kTieReqFieldNumber = 8,
    kTieRespFieldNumber = 14,
    kSurrenderReqFieldNumber = 9,
    kMessgFieldNumber = 10,
    kContinueGameReqFieldNumber = 11,
    kQuitRoomReqFieldNumber = 12,
    kNormalMatchReqFieldNumber = 13,
    kRankMatchReqFieldNumber = 16,
  };
  // .GoBang.TYPE type = 1;
  void clear_type();
  ::GoBang::TYPE type() const;
  void set_type(::GoBang::TYPE value);
  private:
  ::GoBang::TYPE _internal_type() const;
  void _internal_set_type(::GoBang::TYPE value);
  public:

  // .GoBang.LoginRequest loginReq = 2;
  bool has_loginreq() const;
  private:
  bool _internal_has_loginreq() const;
  public:
  void clear_loginreq();
  const ::GoBang::LoginRequest& loginreq() const;
  PROTOBUF_NODISCARD ::GoBang::LoginRequest* release_loginreq();
  ::GoBang::LoginRequest* mutable_loginreq();
  void set_allocated_loginreq(::GoBang::LoginRequest* loginreq);
  private:
  const ::GoBang::LoginRequest& _internal_loginreq() const;
  ::GoBang::LoginRequest* _internal_mutable_loginreq();
  public:
  void unsafe_arena_set_allocated_loginreq(
      ::GoBang::LoginRequest* loginreq);
  ::GoBang::LoginRequest* unsafe_arena_release_loginreq();

  // .GoBang.RegisterRequest RegisterReq = 3;
  bool has_registerreq() const;
  private:
  bool _internal_has_registerreq() const;
  public:
  void clear_registerreq();
  const ::GoBang::RegisterRequest& registerreq() const;
  PROTOBUF_NODISCARD ::GoBang::RegisterRequest* release_registerreq();
  ::GoBang::RegisterRequest* mutable_registerreq();
  void set_allocated_registerreq(::GoBang::RegisterRequest* registerreq);
  private:
  const ::GoBang::RegisterRequest& _internal_registerreq() const;
  ::GoBang::RegisterRequest* _internal_mutable_registerreq();
  public:
  void unsafe_arena_set_allocated_registerreq(
      ::GoBang::RegisterRequest* registerreq);
  ::GoBang::RegisterRequest* unsafe_arena_release_registerreq();

  // .GoBang.RankListRequest rankListReq = 4;
  bool has_ranklistreq() const;
  private:
  bool _internal_has_ranklistreq() const;
  public:
  void clear_ranklistreq();
  const ::GoBang::RankListRequest& ranklistreq() const;
  PROTOBUF_NODISCARD ::GoBang::RankListRequest* release_ranklistreq();
  ::GoBang::RankListRequest* mutable_ranklistreq();
  void set_allocated_ranklistreq(::GoBang::RankListRequest* ranklistreq);
  private:
  const ::GoBang::RankListRequest& _internal_ranklistreq() const;
  ::GoBang::RankListRequest* _internal_mutable_ranklistreq();
  public:
  void unsafe_arena_set_allocated_ranklistreq(
      ::GoBang::RankListRequest* ranklistreq);
  ::GoBang::RankListRequest* unsafe_arena_release_ranklistreq();

  // .GoBang.CreateRoomRequest createRoomReq = 5;
  bool has_createroomreq() const;
  private:
  bool _internal_has_createroomreq() const;
  public:
  void clear_createroomreq();
  const ::GoBang::CreateRoomRequest& createroomreq() const;
  PROTOBUF_NODISCARD ::GoBang::CreateRoomRequest* release_createroomreq();
  ::GoBang::CreateRoomRequest* mutable_createroomreq();
  void set_allocated_createroomreq(::GoBang::CreateRoomRequest* createroomreq);
  private:
  const ::GoBang::CreateRoomRequest& _internal_createroomreq() const;
  ::GoBang::CreateRoomRequest* _internal_mutable_createroomreq();
  public:
  void unsafe_arena_set_allocated_createroomreq(
      ::GoBang::CreateRoomRequest* createroomreq);
  ::GoBang::CreateRoomRequest* unsafe_arena_release_createroomreq();

  // .GoBang.SetPieceRequest setPieceReq = 6;
  bool has_setpiecereq() const;
  private:
  bool _internal_has_setpiecereq() const;
  public:
  void clear_setpiecereq();
  const ::GoBang::SetPieceRequest& setpiecereq() const;
  PROTOBUF_NODISCARD ::GoBang::SetPieceRequest* release_setpiecereq();
  ::GoBang::SetPieceRequest* mutable_setpiecereq();
  void set_allocated_setpiecereq(::GoBang::SetPieceRequest* setpiecereq);
  private:
  const ::GoBang::SetPieceRequest& _internal_setpiecereq() const;
  ::GoBang::SetPieceRequest* _internal_mutable_setpiecereq();
  public:
  void unsafe_arena_set_allocated_setpiecereq(
      ::GoBang::SetPieceRequest* setpiecereq);
  ::GoBang::SetPieceRequest* unsafe_arena_release_setpiecereq();

  // .GoBang.UndoRequest undoReq = 7;
  bool has_undoreq() const;
  private:
  bool _internal_has_undoreq() const;
  public:
  void clear_undoreq();
  const ::GoBang::UndoRequest& undoreq() const;
  PROTOBUF_NODISCARD ::GoBang::UndoRequest* release_undoreq();
  ::GoBang::UndoRequest* mutable_undoreq();
  void set_allocated_undoreq(::GoBang::UndoRequest* undoreq);
  private:
  const ::GoBang::UndoRequest& _internal_undoreq() const;
  ::GoBang::UndoRequest* _internal_mutable_undoreq();
  public:
  void unsafe_arena_set_allocated_undoreq(
      ::GoBang::UndoRequest* undoreq);
  ::GoBang::UndoRequest* unsafe_arena_release_undoreq();

  // .GoBang.UndoResponse undoResp = 15;
  bool has_undoresp() const;
  private:
  bool _internal_has_undoresp() const;
  public:
  void clear_undoresp();
  const ::GoBang::UndoResponse& undoresp() const;
  PROTOBUF_NODISCARD ::GoBang::UndoResponse* release_undoresp();
  ::GoBang::UndoResponse* mutable_undoresp();
  void set_allocated_undoresp(::GoBang::UndoResponse* undoresp);
  private:
  const ::GoBang::UndoResponse& _internal_undoresp() const;
  ::GoBang::UndoResponse* _internal_mutable_undoresp();
  public:
  void unsafe_arena_set_allocated_undoresp(
      ::GoBang::UndoResponse* undoresp);
  ::GoBang::UndoResponse* unsafe_arena_release_undoresp();

  // .GoBang.TieRequest tieReq = 8;
  bool has_tiereq() const;
  private:
  bool _internal_has_tiereq() const;
  public:
  void clear_tiereq();
  const ::GoBang::TieRequest& tiereq() const;
  PROTOBUF_NODISCARD ::GoBang::TieRequest* release_tiereq();
  ::GoBang::TieRequest* mutable_tiereq();
  void set_allocated_tiereq(::GoBang::TieRequest* tiereq);
  private:
  const ::GoBang::TieRequest& _internal_tiereq() const;
  ::GoBang::TieRequest* _internal_mutable_tiereq();
  public:
  void unsafe_arena_set_allocated_tiereq(
      ::GoBang::TieRequest* tiereq);
  ::GoBang::TieRequest* unsafe_arena_release_tiereq();

  // .GoBang.TieResponse tieResp = 14;
  bool has_tieresp() const;
  private:
  bool _internal_has_tieresp() const;
  public:
  void clear_tieresp();
  const ::GoBang::TieResponse& tieresp() const;
  PROTOBUF_NODISCARD ::GoBang::TieResponse* release_tieresp();
  ::GoBang::TieResponse* mutable_tieresp();
  void set_allocated_tieresp(::GoBang::TieResponse* tieresp);
  private:
  const ::GoBang::TieResponse& _internal_tieresp() const;
  ::GoBang::TieResponse* _internal_mutable_tieresp();
  public:
  void unsafe_arena_set_allocated_tieresp(
      ::GoBang::TieResponse* tieresp);
  ::GoBang::TieResponse* unsafe_arena_release_tieresp();

  // .GoBang.SurrenderRequest surrenderReq = 9;
  bool has_surrenderreq() const;
  private:
  bool _internal_has_surrenderreq() const;
  public:
  void clear_surrenderreq();
  const ::GoBang::SurrenderRequest& surrenderreq() const;
  PROTOBUF_NODISCARD ::GoBang::SurrenderRequest* release_surrenderreq();
  ::GoBang::SurrenderRequest* mutable_surrenderreq();
  void set_allocated_surrenderreq(::GoBang::SurrenderRequest* surrenderreq);
  private:
  const ::GoBang::SurrenderRequest& _internal_surrenderreq() const;
  ::GoBang::SurrenderRequest* _internal_mutable_surrenderreq();
  public:
  void unsafe_arena_set_allocated_surrenderreq(
      ::GoBang::SurrenderRequest* surrenderreq);
  ::GoBang::SurrenderRequest* unsafe_arena_release_surrenderreq();

  // .GoBang.Messg messg = 10;
  bool has_messg() const;
  private:
  bool _internal_has_messg() const;
  public:
  void clear_messg();
  const ::GoBang::Messg& messg() const;
  PROTOBUF_NODISCARD ::GoBang::Messg* release_messg();
  ::GoBang::Messg* mutable_messg();
  void set_allocated_messg(::GoBang::Messg* messg);
  private:
  const ::GoBang::Messg& _internal_messg() const;
  ::GoBang::Messg* _internal_mutable_messg();
  public:
  void unsafe_arena_set_allocated_messg(
      ::GoBang::Messg* messg);
  ::GoBang::Messg* unsafe_arena_release_messg();

  // .GoBang.ContinueGameRequest continueGameReq = 11;
  bool has_continuegamereq() const;
  private:
  bool _internal_has_continuegamereq() const;
  public:
  void clear_continuegamereq();
  const ::GoBang::ContinueGameRequest& continuegamereq() const;
  PROTOBUF_NODISCARD ::GoBang::ContinueGameRequest* release_continuegamereq();
  ::GoBang::ContinueGameRequest* mutable_continuegamereq();
  void set_allocated_continuegamereq(::GoBang::ContinueGameRequest* continuegamereq);
  private:
  const ::GoBang::ContinueGameRequest& _internal_continuegamereq() const;
  ::GoBang::ContinueGameRequest* _internal_mutable_continuegamereq();
  public:
  void unsafe_arena_set_allocated_continuegamereq(
      ::GoBang::ContinueGameRequest* continuegamereq);
  ::GoBang::ContinueGameRequest* unsafe_arena_release_continuegamereq();

  // .GoBang.QuitRoomRequest quitRoomReq = 12;
  bool has_quitroomreq() const;
  private:
  bool _internal_has_quitroomreq() const;
  public:
  void clear_quitroomreq();
  const ::GoBang::QuitRoomRequest& quitroomreq() const;
  PROTOBUF_NODISCARD ::GoBang::QuitRoomRequest* release_quitroomreq();
  ::GoBang::QuitRoomRequest* mutable_quitroomreq();
  void set_allocated_quitroomreq(::GoBang::QuitRoomRequest* quitroomreq);
  private:
  const ::GoBang::QuitRoomRequest& _internal_quitroomreq() const;
  ::GoBang::QuitRoomRequest* _internal_mutable_quitroomreq();
  public:
  void unsafe_arena_set_allocated_quitroomreq(
      ::GoBang::QuitRoomRequest* quitroomreq);
  ::GoBang::QuitRoomRequest* unsafe_arena_release_quitroomreq();

  // .GoBang.NormalMatchRequest normalMatchReq = 13;
  bool has_normalmatchreq() const;
  private:
  bool _internal_has_normalmatchreq() const;
  public:
  void clear_normalmatchreq();
  const ::GoBang::NormalMatchRequest& normalmatchreq() const;
  PROTOBUF_NODISCARD ::GoBang::NormalMatchRequest* release_normalmatchreq();
  ::GoBang::NormalMatchRequest* mutable_normalmatchreq();
  void set_allocated_normalmatchreq(::GoBang::NormalMatchRequest* normalmatchreq);
  private:
  const ::GoBang::NormalMatchRequest& _internal_normalmatchreq() const;
  ::GoBang::NormalMatchRequest* _internal_mutable_normalmatchreq();
  public:
  void unsafe_arena_set_allocated_normalmatchreq(
      ::GoBang::NormalMatchRequest* normalmatchreq);
  ::GoBang::NormalMatchRequest* unsafe_arena_release_normalmatchreq();

  // .GoBang.RankMatchRequest rankMatchReq = 16;
  bool has_rankmatchreq() const;
  private:
  bool _internal_has_rankmatchreq() const;
  public:
  void clear_rankmatchreq();
  const ::GoBang::RankMatchRequest& rankmatchreq() const;
  PROTOBUF_NODISCARD ::GoBang::RankMatchRequest* release_rankmatchreq();
  ::GoBang::RankMatchRequest* mutable_rankmatchreq();
  void set_allocated_rankmatchreq(::GoBang::RankMatchRequest* rankmatchreq);
  private:
  const ::GoBang::RankMatchRequest& _internal_rankmatchreq() const;
  ::GoBang::RankMatchRequest* _internal_mutable_rankmatchreq();
  public:
  void unsafe_arena_set_allocated_rankmatchreq(
      ::GoBang::RankMatchRequest* rankmatchreq);
  ::GoBang::RankMatchRequest* unsafe_arena_release_rankmatchreq();

  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:GoBang.goBangRequest)
 private:
  class _Internal;
  void set_has_loginreq();
  void set_has_registerreq();
  void set_has_ranklistreq();
  void set_has_createroomreq();
  void set_has_setpiecereq();
  void set_has_undoreq();
  void set_has_undoresp();
  void set_has_tiereq();
  void set_has_tieresp();
  void set_has_surrenderreq();
  void set_has_messg();
  void set_has_continuegamereq();
  void set_has_quitroomreq();
  void set_has_normalmatchreq();
  void set_has_rankmatchreq();

  inline bool has_request() const;
  inline void clear_has_request();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    union RequestUnion {
      constexpr RequestUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::GoBang::LoginRequest* loginreq_;
      ::GoBang::RegisterRequest* registerreq_;
      ::GoBang::RankListRequest* ranklistreq_;
      ::GoBang::CreateRoomRequest* createroomreq_;
      ::GoBang::SetPieceRequest* setpiecereq_;
      ::GoBang::UndoRequest* undoreq_;
      ::GoBang::UndoResponse* undoresp_;
      ::GoBang::TieRequest* tiereq_;
      ::GoBang::TieResponse* tieresp_;
      ::GoBang::SurrenderRequest* surrenderreq_;
      ::GoBang::Messg* messg_;
      ::GoBang::ContinueGameRequest* continuegamereq_;
      ::GoBang::QuitRoomRequest* quitroomreq_;
      ::GoBang::NormalMatchRequest* normalmatchreq_;
      ::GoBang::RankMatchRequest* rankmatchreq_;
    } request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class goBangResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GoBang.goBangResponse) */ {
 public:
  inline goBangResponse() : goBangResponse(nullptr) {}
  ~goBangResponse() override;
  explicit PROTOBUF_CONSTEXPR goBangResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  goBangResponse(const goBangResponse& from);
  goBangResponse(goBangResponse&& from) noexcept
    : goBangResponse() {
    *this = ::std::move(from);
  }

  inline goBangResponse& operator=(const goBangResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline goBangResponse& operator=(goBangResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const goBangResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kLoginResp = 2,
    kRegisterResp = 3,
    kRankListResp = 4,
    kCreateRoomResp = 5,
    kSetPieceResp = 6,
    kUndoResponse = 7,
    kTieResp = 8,
    kUndoReq = 17,
    kUndoResp = 18,
    kMessg = 10,
    kContinueGameResp = 11,
    kQuitRoomResp = 12,
    kGameStart = 13,
    kGameOver = 14,
    kNormalMatchResp = 15,
    kRankMatchResp = 16,
    RESPONSE_NOT_SET = 0,
  };

  static inline const goBangResponse* internal_default_instance() {
    return reinterpret_cast<const goBangResponse*>(
               &_goBangResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(goBangResponse& a, goBangResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(goBangResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(goBangResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  goBangResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<goBangResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const goBangResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const goBangResponse& from) {
    goBangResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(goBangResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GoBang.goBangResponse";
  }
  protected:
  explicit goBangResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kLoginRespFieldNumber = 2,
    kRegisterRespFieldNumber = 3,
    kRankListRespFieldNumber = 4,
    kCreateRoomRespFieldNumber = 5,
    kSetPieceRespFieldNumber = 6,
    kUndoResponseFieldNumber = 7,
    kTieRespFieldNumber = 8,
    kUndoReqFieldNumber = 17,
    kUndoRespFieldNumber = 18,
    kMessgFieldNumber = 10,
    kContinueGameRespFieldNumber = 11,
    kQuitRoomRespFieldNumber = 12,
    kGameStartFieldNumber = 13,
    kGameOverFieldNumber = 14,
    kNormalMatchRespFieldNumber = 15,
    kRankMatchRespFieldNumber = 16,
  };
  // .GoBang.TYPE type = 1;
  void clear_type();
  ::GoBang::TYPE type() const;
  void set_type(::GoBang::TYPE value);
  private:
  ::GoBang::TYPE _internal_type() const;
  void _internal_set_type(::GoBang::TYPE value);
  public:

  // .GoBang.LoginResponse loginResp = 2;
  bool has_loginresp() const;
  private:
  bool _internal_has_loginresp() const;
  public:
  void clear_loginresp();
  const ::GoBang::LoginResponse& loginresp() const;
  PROTOBUF_NODISCARD ::GoBang::LoginResponse* release_loginresp();
  ::GoBang::LoginResponse* mutable_loginresp();
  void set_allocated_loginresp(::GoBang::LoginResponse* loginresp);
  private:
  const ::GoBang::LoginResponse& _internal_loginresp() const;
  ::GoBang::LoginResponse* _internal_mutable_loginresp();
  public:
  void unsafe_arena_set_allocated_loginresp(
      ::GoBang::LoginResponse* loginresp);
  ::GoBang::LoginResponse* unsafe_arena_release_loginresp();

  // .GoBang.RegisterResponse registerResp = 3;
  bool has_registerresp() const;
  private:
  bool _internal_has_registerresp() const;
  public:
  void clear_registerresp();
  const ::GoBang::RegisterResponse& registerresp() const;
  PROTOBUF_NODISCARD ::GoBang::RegisterResponse* release_registerresp();
  ::GoBang::RegisterResponse* mutable_registerresp();
  void set_allocated_registerresp(::GoBang::RegisterResponse* registerresp);
  private:
  const ::GoBang::RegisterResponse& _internal_registerresp() const;
  ::GoBang::RegisterResponse* _internal_mutable_registerresp();
  public:
  void unsafe_arena_set_allocated_registerresp(
      ::GoBang::RegisterResponse* registerresp);
  ::GoBang::RegisterResponse* unsafe_arena_release_registerresp();

  // .GoBang.RankListResponse rankListResp = 4;
  bool has_ranklistresp() const;
  private:
  bool _internal_has_ranklistresp() const;
  public:
  void clear_ranklistresp();
  const ::GoBang::RankListResponse& ranklistresp() const;
  PROTOBUF_NODISCARD ::GoBang::RankListResponse* release_ranklistresp();
  ::GoBang::RankListResponse* mutable_ranklistresp();
  void set_allocated_ranklistresp(::GoBang::RankListResponse* ranklistresp);
  private:
  const ::GoBang::RankListResponse& _internal_ranklistresp() const;
  ::GoBang::RankListResponse* _internal_mutable_ranklistresp();
  public:
  void unsafe_arena_set_allocated_ranklistresp(
      ::GoBang::RankListResponse* ranklistresp);
  ::GoBang::RankListResponse* unsafe_arena_release_ranklistresp();

  // .GoBang.CreateRoomResponse createRoomResp = 5;
  bool has_createroomresp() const;
  private:
  bool _internal_has_createroomresp() const;
  public:
  void clear_createroomresp();
  const ::GoBang::CreateRoomResponse& createroomresp() const;
  PROTOBUF_NODISCARD ::GoBang::CreateRoomResponse* release_createroomresp();
  ::GoBang::CreateRoomResponse* mutable_createroomresp();
  void set_allocated_createroomresp(::GoBang::CreateRoomResponse* createroomresp);
  private:
  const ::GoBang::CreateRoomResponse& _internal_createroomresp() const;
  ::GoBang::CreateRoomResponse* _internal_mutable_createroomresp();
  public:
  void unsafe_arena_set_allocated_createroomresp(
      ::GoBang::CreateRoomResponse* createroomresp);
  ::GoBang::CreateRoomResponse* unsafe_arena_release_createroomresp();

  // .GoBang.SetPieceResponse setPieceResp = 6;
  bool has_setpieceresp() const;
  private:
  bool _internal_has_setpieceresp() const;
  public:
  void clear_setpieceresp();
  const ::GoBang::SetPieceResponse& setpieceresp() const;
  PROTOBUF_NODISCARD ::GoBang::SetPieceResponse* release_setpieceresp();
  ::GoBang::SetPieceResponse* mutable_setpieceresp();
  void set_allocated_setpieceresp(::GoBang::SetPieceResponse* setpieceresp);
  private:
  const ::GoBang::SetPieceResponse& _internal_setpieceresp() const;
  ::GoBang::SetPieceResponse* _internal_mutable_setpieceresp();
  public:
  void unsafe_arena_set_allocated_setpieceresp(
      ::GoBang::SetPieceResponse* setpieceresp);
  ::GoBang::SetPieceResponse* unsafe_arena_release_setpieceresp();

  // .GoBang.UndoResponse undoResponse = 7;
  bool has_undoresponse() const;
  private:
  bool _internal_has_undoresponse() const;
  public:
  void clear_undoresponse();
  const ::GoBang::UndoResponse& undoresponse() const;
  PROTOBUF_NODISCARD ::GoBang::UndoResponse* release_undoresponse();
  ::GoBang::UndoResponse* mutable_undoresponse();
  void set_allocated_undoresponse(::GoBang::UndoResponse* undoresponse);
  private:
  const ::GoBang::UndoResponse& _internal_undoresponse() const;
  ::GoBang::UndoResponse* _internal_mutable_undoresponse();
  public:
  void unsafe_arena_set_allocated_undoresponse(
      ::GoBang::UndoResponse* undoresponse);
  ::GoBang::UndoResponse* unsafe_arena_release_undoresponse();

  // .GoBang.TieResponse tieResp = 8;
  bool has_tieresp() const;
  private:
  bool _internal_has_tieresp() const;
  public:
  void clear_tieresp();
  const ::GoBang::TieResponse& tieresp() const;
  PROTOBUF_NODISCARD ::GoBang::TieResponse* release_tieresp();
  ::GoBang::TieResponse* mutable_tieresp();
  void set_allocated_tieresp(::GoBang::TieResponse* tieresp);
  private:
  const ::GoBang::TieResponse& _internal_tieresp() const;
  ::GoBang::TieResponse* _internal_mutable_tieresp();
  public:
  void unsafe_arena_set_allocated_tieresp(
      ::GoBang::TieResponse* tieresp);
  ::GoBang::TieResponse* unsafe_arena_release_tieresp();

  // .GoBang.UndoRequest undoReq = 17;
  bool has_undoreq() const;
  private:
  bool _internal_has_undoreq() const;
  public:
  void clear_undoreq();
  const ::GoBang::UndoRequest& undoreq() const;
  PROTOBUF_NODISCARD ::GoBang::UndoRequest* release_undoreq();
  ::GoBang::UndoRequest* mutable_undoreq();
  void set_allocated_undoreq(::GoBang::UndoRequest* undoreq);
  private:
  const ::GoBang::UndoRequest& _internal_undoreq() const;
  ::GoBang::UndoRequest* _internal_mutable_undoreq();
  public:
  void unsafe_arena_set_allocated_undoreq(
      ::GoBang::UndoRequest* undoreq);
  ::GoBang::UndoRequest* unsafe_arena_release_undoreq();

  // .GoBang.UndoResponse undoResp = 18;
  bool has_undoresp() const;
  private:
  bool _internal_has_undoresp() const;
  public:
  void clear_undoresp();
  const ::GoBang::UndoResponse& undoresp() const;
  PROTOBUF_NODISCARD ::GoBang::UndoResponse* release_undoresp();
  ::GoBang::UndoResponse* mutable_undoresp();
  void set_allocated_undoresp(::GoBang::UndoResponse* undoresp);
  private:
  const ::GoBang::UndoResponse& _internal_undoresp() const;
  ::GoBang::UndoResponse* _internal_mutable_undoresp();
  public:
  void unsafe_arena_set_allocated_undoresp(
      ::GoBang::UndoResponse* undoresp);
  ::GoBang::UndoResponse* unsafe_arena_release_undoresp();

  // .GoBang.Messg messg = 10;
  bool has_messg() const;
  private:
  bool _internal_has_messg() const;
  public:
  void clear_messg();
  const ::GoBang::Messg& messg() const;
  PROTOBUF_NODISCARD ::GoBang::Messg* release_messg();
  ::GoBang::Messg* mutable_messg();
  void set_allocated_messg(::GoBang::Messg* messg);
  private:
  const ::GoBang::Messg& _internal_messg() const;
  ::GoBang::Messg* _internal_mutable_messg();
  public:
  void unsafe_arena_set_allocated_messg(
      ::GoBang::Messg* messg);
  ::GoBang::Messg* unsafe_arena_release_messg();

  // .GoBang.ContinueGameResponse continueGameResp = 11;
  bool has_continuegameresp() const;
  private:
  bool _internal_has_continuegameresp() const;
  public:
  void clear_continuegameresp();
  const ::GoBang::ContinueGameResponse& continuegameresp() const;
  PROTOBUF_NODISCARD ::GoBang::ContinueGameResponse* release_continuegameresp();
  ::GoBang::ContinueGameResponse* mutable_continuegameresp();
  void set_allocated_continuegameresp(::GoBang::ContinueGameResponse* continuegameresp);
  private:
  const ::GoBang::ContinueGameResponse& _internal_continuegameresp() const;
  ::GoBang::ContinueGameResponse* _internal_mutable_continuegameresp();
  public:
  void unsafe_arena_set_allocated_continuegameresp(
      ::GoBang::ContinueGameResponse* continuegameresp);
  ::GoBang::ContinueGameResponse* unsafe_arena_release_continuegameresp();

  // .GoBang.QuitRoomResponse quitRoomResp = 12;
  bool has_quitroomresp() const;
  private:
  bool _internal_has_quitroomresp() const;
  public:
  void clear_quitroomresp();
  const ::GoBang::QuitRoomResponse& quitroomresp() const;
  PROTOBUF_NODISCARD ::GoBang::QuitRoomResponse* release_quitroomresp();
  ::GoBang::QuitRoomResponse* mutable_quitroomresp();
  void set_allocated_quitroomresp(::GoBang::QuitRoomResponse* quitroomresp);
  private:
  const ::GoBang::QuitRoomResponse& _internal_quitroomresp() const;
  ::GoBang::QuitRoomResponse* _internal_mutable_quitroomresp();
  public:
  void unsafe_arena_set_allocated_quitroomresp(
      ::GoBang::QuitRoomResponse* quitroomresp);
  ::GoBang::QuitRoomResponse* unsafe_arena_release_quitroomresp();

  // .GoBang.GameStart gameStart = 13;
  bool has_gamestart() const;
  private:
  bool _internal_has_gamestart() const;
  public:
  void clear_gamestart();
  const ::GoBang::GameStart& gamestart() const;
  PROTOBUF_NODISCARD ::GoBang::GameStart* release_gamestart();
  ::GoBang::GameStart* mutable_gamestart();
  void set_allocated_gamestart(::GoBang::GameStart* gamestart);
  private:
  const ::GoBang::GameStart& _internal_gamestart() const;
  ::GoBang::GameStart* _internal_mutable_gamestart();
  public:
  void unsafe_arena_set_allocated_gamestart(
      ::GoBang::GameStart* gamestart);
  ::GoBang::GameStart* unsafe_arena_release_gamestart();

  // .GoBang.GameOver gameOver = 14;
  bool has_gameover() const;
  private:
  bool _internal_has_gameover() const;
  public:
  void clear_gameover();
  const ::GoBang::GameOver& gameover() const;
  PROTOBUF_NODISCARD ::GoBang::GameOver* release_gameover();
  ::GoBang::GameOver* mutable_gameover();
  void set_allocated_gameover(::GoBang::GameOver* gameover);
  private:
  const ::GoBang::GameOver& _internal_gameover() const;
  ::GoBang::GameOver* _internal_mutable_gameover();
  public:
  void unsafe_arena_set_allocated_gameover(
      ::GoBang::GameOver* gameover);
  ::GoBang::GameOver* unsafe_arena_release_gameover();

  // .GoBang.NormalMatchResponse normalMatchResp = 15;
  bool has_normalmatchresp() const;
  private:
  bool _internal_has_normalmatchresp() const;
  public:
  void clear_normalmatchresp();
  const ::GoBang::NormalMatchResponse& normalmatchresp() const;
  PROTOBUF_NODISCARD ::GoBang::NormalMatchResponse* release_normalmatchresp();
  ::GoBang::NormalMatchResponse* mutable_normalmatchresp();
  void set_allocated_normalmatchresp(::GoBang::NormalMatchResponse* normalmatchresp);
  private:
  const ::GoBang::NormalMatchResponse& _internal_normalmatchresp() const;
  ::GoBang::NormalMatchResponse* _internal_mutable_normalmatchresp();
  public:
  void unsafe_arena_set_allocated_normalmatchresp(
      ::GoBang::NormalMatchResponse* normalmatchresp);
  ::GoBang::NormalMatchResponse* unsafe_arena_release_normalmatchresp();

  // .GoBang.RankMatchResponse rankMatchResp = 16;
  bool has_rankmatchresp() const;
  private:
  bool _internal_has_rankmatchresp() const;
  public:
  void clear_rankmatchresp();
  const ::GoBang::RankMatchResponse& rankmatchresp() const;
  PROTOBUF_NODISCARD ::GoBang::RankMatchResponse* release_rankmatchresp();
  ::GoBang::RankMatchResponse* mutable_rankmatchresp();
  void set_allocated_rankmatchresp(::GoBang::RankMatchResponse* rankmatchresp);
  private:
  const ::GoBang::RankMatchResponse& _internal_rankmatchresp() const;
  ::GoBang::RankMatchResponse* _internal_mutable_rankmatchresp();
  public:
  void unsafe_arena_set_allocated_rankmatchresp(
      ::GoBang::RankMatchResponse* rankmatchresp);
  ::GoBang::RankMatchResponse* unsafe_arena_release_rankmatchresp();

  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:GoBang.goBangResponse)
 private:
  class _Internal;
  void set_has_loginresp();
  void set_has_registerresp();
  void set_has_ranklistresp();
  void set_has_createroomresp();
  void set_has_setpieceresp();
  void set_has_undoresponse();
  void set_has_tieresp();
  void set_has_undoreq();
  void set_has_undoresp();
  void set_has_messg();
  void set_has_continuegameresp();
  void set_has_quitroomresp();
  void set_has_gamestart();
  void set_has_gameover();
  void set_has_normalmatchresp();
  void set_has_rankmatchresp();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    union ResponseUnion {
      constexpr ResponseUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::GoBang::LoginResponse* loginresp_;
      ::GoBang::RegisterResponse* registerresp_;
      ::GoBang::RankListResponse* ranklistresp_;
      ::GoBang::CreateRoomResponse* createroomresp_;
      ::GoBang::SetPieceResponse* setpieceresp_;
      ::GoBang::UndoResponse* undoresponse_;
      ::GoBang::TieResponse* tieresp_;
      ::GoBang::UndoRequest* undoreq_;
      ::GoBang::UndoResponse* undoresp_;
      ::GoBang::Messg* messg_;
      ::GoBang::ContinueGameResponse* continuegameresp_;
      ::GoBang::QuitRoomResponse* quitroomresp_;
      ::GoBang::GameStart* gamestart_;
      ::GoBang::GameOver* gameover_;
      ::GoBang::NormalMatchResponse* normalmatchresp_;
      ::GoBang::RankMatchResponse* rankmatchresp_;
    } response_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LoginRequest

// string name = 1;
inline void LoginRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& LoginRequest::name() const {
  // @@protoc_insertion_point(field_get:GoBang.LoginRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.LoginRequest.name)
}
inline std::string* LoginRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:GoBang.LoginRequest.name)
  return _s;
}
inline const std::string& LoginRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void LoginRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_name() {
  // @@protoc_insertion_point(field_release:GoBang.LoginRequest.name)
  return _impl_.name_.Release();
}
inline void LoginRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.LoginRequest.name)
}

// string passwd = 2;
inline void LoginRequest::clear_passwd() {
  _impl_.passwd_.ClearToEmpty();
}
inline const std::string& LoginRequest::passwd() const {
  // @@protoc_insertion_point(field_get:GoBang.LoginRequest.passwd)
  return _internal_passwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_passwd(ArgT0&& arg0, ArgT... args) {
 
 _impl_.passwd_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.LoginRequest.passwd)
}
inline std::string* LoginRequest::mutable_passwd() {
  std::string* _s = _internal_mutable_passwd();
  // @@protoc_insertion_point(field_mutable:GoBang.LoginRequest.passwd)
  return _s;
}
inline const std::string& LoginRequest::_internal_passwd() const {
  return _impl_.passwd_.Get();
}
inline void LoginRequest::_internal_set_passwd(const std::string& value) {
  
  _impl_.passwd_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_passwd() {
  
  return _impl_.passwd_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_passwd() {
  // @@protoc_insertion_point(field_release:GoBang.LoginRequest.passwd)
  return _impl_.passwd_.Release();
}
inline void LoginRequest::set_allocated_passwd(std::string* passwd) {
  if (passwd != nullptr) {
    
  } else {
    
  }
  _impl_.passwd_.SetAllocated(passwd, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.passwd_.IsDefault()) {
    _impl_.passwd_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.LoginRequest.passwd)
}

// -------------------------------------------------------------------

// LoginResponse

// bool success = 1;
inline void LoginResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool LoginResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool LoginResponse::success() const {
  // @@protoc_insertion_point(field_get:GoBang.LoginResponse.success)
  return _internal_success();
}
inline void LoginResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void LoginResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:GoBang.LoginResponse.success)
}

// string msg = 2;
inline void LoginResponse::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& LoginResponse::msg() const {
  // @@protoc_insertion_point(field_get:GoBang.LoginResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.LoginResponse.msg)
}
inline std::string* LoginResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:GoBang.LoginResponse.msg)
  return _s;
}
inline const std::string& LoginResponse::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void LoginResponse::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_msg() {
  // @@protoc_insertion_point(field_release:GoBang.LoginResponse.msg)
  return _impl_.msg_.Release();
}
inline void LoginResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.LoginResponse.msg)
}

// string uid = 3;
inline void LoginResponse::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& LoginResponse::uid() const {
  // @@protoc_insertion_point(field_get:GoBang.LoginResponse.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.LoginResponse.uid)
}
inline std::string* LoginResponse::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:GoBang.LoginResponse.uid)
  return _s;
}
inline const std::string& LoginResponse::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void LoginResponse::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_uid() {
  // @@protoc_insertion_point(field_release:GoBang.LoginResponse.uid)
  return _impl_.uid_.Release();
}
inline void LoginResponse::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.LoginResponse.uid)
}

// int32 points = 4;
inline void LoginResponse::clear_points() {
  _impl_.points_ = 0;
}
inline int32_t LoginResponse::_internal_points() const {
  return _impl_.points_;
}
inline int32_t LoginResponse::points() const {
  // @@protoc_insertion_point(field_get:GoBang.LoginResponse.points)
  return _internal_points();
}
inline void LoginResponse::_internal_set_points(int32_t value) {
  
  _impl_.points_ = value;
}
inline void LoginResponse::set_points(int32_t value) {
  _internal_set_points(value);
  // @@protoc_insertion_point(field_set:GoBang.LoginResponse.points)
}

// -------------------------------------------------------------------

// RegisterRequest

// string name = 1;
inline void RegisterRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RegisterRequest::name() const {
  // @@protoc_insertion_point(field_get:GoBang.RegisterRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.RegisterRequest.name)
}
inline std::string* RegisterRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:GoBang.RegisterRequest.name)
  return _s;
}
inline const std::string& RegisterRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RegisterRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_name() {
  // @@protoc_insertion_point(field_release:GoBang.RegisterRequest.name)
  return _impl_.name_.Release();
}
inline void RegisterRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.RegisterRequest.name)
}

// string passwd = 2;
inline void RegisterRequest::clear_passwd() {
  _impl_.passwd_.ClearToEmpty();
}
inline const std::string& RegisterRequest::passwd() const {
  // @@protoc_insertion_point(field_get:GoBang.RegisterRequest.passwd)
  return _internal_passwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_passwd(ArgT0&& arg0, ArgT... args) {
 
 _impl_.passwd_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.RegisterRequest.passwd)
}
inline std::string* RegisterRequest::mutable_passwd() {
  std::string* _s = _internal_mutable_passwd();
  // @@protoc_insertion_point(field_mutable:GoBang.RegisterRequest.passwd)
  return _s;
}
inline const std::string& RegisterRequest::_internal_passwd() const {
  return _impl_.passwd_.Get();
}
inline void RegisterRequest::_internal_set_passwd(const std::string& value) {
  
  _impl_.passwd_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_passwd() {
  
  return _impl_.passwd_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_passwd() {
  // @@protoc_insertion_point(field_release:GoBang.RegisterRequest.passwd)
  return _impl_.passwd_.Release();
}
inline void RegisterRequest::set_allocated_passwd(std::string* passwd) {
  if (passwd != nullptr) {
    
  } else {
    
  }
  _impl_.passwd_.SetAllocated(passwd, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.passwd_.IsDefault()) {
    _impl_.passwd_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.RegisterRequest.passwd)
}

// -------------------------------------------------------------------

// RegisterResponse

// bool success = 1;
inline void RegisterResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool RegisterResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool RegisterResponse::success() const {
  // @@protoc_insertion_point(field_get:GoBang.RegisterResponse.success)
  return _internal_success();
}
inline void RegisterResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void RegisterResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:GoBang.RegisterResponse.success)
}

// string msg = 2;
inline void RegisterResponse::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& RegisterResponse::msg() const {
  // @@protoc_insertion_point(field_get:GoBang.RegisterResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.RegisterResponse.msg)
}
inline std::string* RegisterResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:GoBang.RegisterResponse.msg)
  return _s;
}
inline const std::string& RegisterResponse::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void RegisterResponse::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterResponse::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterResponse::release_msg() {
  // @@protoc_insertion_point(field_release:GoBang.RegisterResponse.msg)
  return _impl_.msg_.Release();
}
inline void RegisterResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.RegisterResponse.msg)
}

// -------------------------------------------------------------------

// RankListRequest

// int32 start = 1;
inline void RankListRequest::clear_start() {
  _impl_.start_ = 0;
}
inline int32_t RankListRequest::_internal_start() const {
  return _impl_.start_;
}
inline int32_t RankListRequest::start() const {
  // @@protoc_insertion_point(field_get:GoBang.RankListRequest.start)
  return _internal_start();
}
inline void RankListRequest::_internal_set_start(int32_t value) {
  
  _impl_.start_ = value;
}
inline void RankListRequest::set_start(int32_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:GoBang.RankListRequest.start)
}

// int32 cnt = 2;
inline void RankListRequest::clear_cnt() {
  _impl_.cnt_ = 0;
}
inline int32_t RankListRequest::_internal_cnt() const {
  return _impl_.cnt_;
}
inline int32_t RankListRequest::cnt() const {
  // @@protoc_insertion_point(field_get:GoBang.RankListRequest.cnt)
  return _internal_cnt();
}
inline void RankListRequest::_internal_set_cnt(int32_t value) {
  
  _impl_.cnt_ = value;
}
inline void RankListRequest::set_cnt(int32_t value) {
  _internal_set_cnt(value);
  // @@protoc_insertion_point(field_set:GoBang.RankListRequest.cnt)
}

// -------------------------------------------------------------------

// Player

// string uid = 1;
inline void Player::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& Player::uid() const {
  // @@protoc_insertion_point(field_get:GoBang.Player.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Player::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.Player.uid)
}
inline std::string* Player::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:GoBang.Player.uid)
  return _s;
}
inline const std::string& Player::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void Player::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* Player::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* Player::release_uid() {
  // @@protoc_insertion_point(field_release:GoBang.Player.uid)
  return _impl_.uid_.Release();
}
inline void Player::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.Player.uid)
}

// string name = 2;
inline void Player::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Player::name() const {
  // @@protoc_insertion_point(field_get:GoBang.Player.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Player::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.Player.name)
}
inline std::string* Player::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:GoBang.Player.name)
  return _s;
}
inline const std::string& Player::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Player::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Player::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Player::release_name() {
  // @@protoc_insertion_point(field_release:GoBang.Player.name)
  return _impl_.name_.Release();
}
inline void Player::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.Player.name)
}

// int32 points = 3;
inline void Player::clear_points() {
  _impl_.points_ = 0;
}
inline int32_t Player::_internal_points() const {
  return _impl_.points_;
}
inline int32_t Player::points() const {
  // @@protoc_insertion_point(field_get:GoBang.Player.points)
  return _internal_points();
}
inline void Player::_internal_set_points(int32_t value) {
  
  _impl_.points_ = value;
}
inline void Player::set_points(int32_t value) {
  _internal_set_points(value);
  // @@protoc_insertion_point(field_set:GoBang.Player.points)
}

// -------------------------------------------------------------------

// RankListResponse

// bool success = 1;
inline void RankListResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool RankListResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool RankListResponse::success() const {
  // @@protoc_insertion_point(field_get:GoBang.RankListResponse.success)
  return _internal_success();
}
inline void RankListResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void RankListResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:GoBang.RankListResponse.success)
}

// string msg = 2;
inline void RankListResponse::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& RankListResponse::msg() const {
  // @@protoc_insertion_point(field_get:GoBang.RankListResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RankListResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.RankListResponse.msg)
}
inline std::string* RankListResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:GoBang.RankListResponse.msg)
  return _s;
}
inline const std::string& RankListResponse::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void RankListResponse::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* RankListResponse::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* RankListResponse::release_msg() {
  // @@protoc_insertion_point(field_release:GoBang.RankListResponse.msg)
  return _impl_.msg_.Release();
}
inline void RankListResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.RankListResponse.msg)
}

// repeated .GoBang.Player list = 3;
inline int RankListResponse::_internal_list_size() const {
  return _impl_.list_.size();
}
inline int RankListResponse::list_size() const {
  return _internal_list_size();
}
inline void RankListResponse::clear_list() {
  _impl_.list_.Clear();
}
inline ::GoBang::Player* RankListResponse::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:GoBang.RankListResponse.list)
  return _impl_.list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GoBang::Player >*
RankListResponse::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:GoBang.RankListResponse.list)
  return &_impl_.list_;
}
inline const ::GoBang::Player& RankListResponse::_internal_list(int index) const {
  return _impl_.list_.Get(index);
}
inline const ::GoBang::Player& RankListResponse::list(int index) const {
  // @@protoc_insertion_point(field_get:GoBang.RankListResponse.list)
  return _internal_list(index);
}
inline ::GoBang::Player* RankListResponse::_internal_add_list() {
  return _impl_.list_.Add();
}
inline ::GoBang::Player* RankListResponse::add_list() {
  ::GoBang::Player* _add = _internal_add_list();
  // @@protoc_insertion_point(field_add:GoBang.RankListResponse.list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GoBang::Player >&
RankListResponse::list() const {
  // @@protoc_insertion_point(field_list:GoBang.RankListResponse.list)
  return _impl_.list_;
}

// -------------------------------------------------------------------

// NormalMatchRequest

// string uid = 1;
inline void NormalMatchRequest::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& NormalMatchRequest::uid() const {
  // @@protoc_insertion_point(field_get:GoBang.NormalMatchRequest.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NormalMatchRequest::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.NormalMatchRequest.uid)
}
inline std::string* NormalMatchRequest::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:GoBang.NormalMatchRequest.uid)
  return _s;
}
inline const std::string& NormalMatchRequest::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void NormalMatchRequest::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* NormalMatchRequest::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* NormalMatchRequest::release_uid() {
  // @@protoc_insertion_point(field_release:GoBang.NormalMatchRequest.uid)
  return _impl_.uid_.Release();
}
inline void NormalMatchRequest::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.NormalMatchRequest.uid)
}

// -------------------------------------------------------------------

// NormalMatchResponse

// bool success = 1;
inline void NormalMatchResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool NormalMatchResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool NormalMatchResponse::success() const {
  // @@protoc_insertion_point(field_get:GoBang.NormalMatchResponse.success)
  return _internal_success();
}
inline void NormalMatchResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void NormalMatchResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:GoBang.NormalMatchResponse.success)
}

// string msg = 2;
inline void NormalMatchResponse::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& NormalMatchResponse::msg() const {
  // @@protoc_insertion_point(field_get:GoBang.NormalMatchResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NormalMatchResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.NormalMatchResponse.msg)
}
inline std::string* NormalMatchResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:GoBang.NormalMatchResponse.msg)
  return _s;
}
inline const std::string& NormalMatchResponse::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void NormalMatchResponse::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* NormalMatchResponse::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* NormalMatchResponse::release_msg() {
  // @@protoc_insertion_point(field_release:GoBang.NormalMatchResponse.msg)
  return _impl_.msg_.Release();
}
inline void NormalMatchResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.NormalMatchResponse.msg)
}

// string rid = 3;
inline void NormalMatchResponse::clear_rid() {
  _impl_.rid_.ClearToEmpty();
}
inline const std::string& NormalMatchResponse::rid() const {
  // @@protoc_insertion_point(field_get:GoBang.NormalMatchResponse.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NormalMatchResponse::set_rid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.NormalMatchResponse.rid)
}
inline std::string* NormalMatchResponse::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:GoBang.NormalMatchResponse.rid)
  return _s;
}
inline const std::string& NormalMatchResponse::_internal_rid() const {
  return _impl_.rid_.Get();
}
inline void NormalMatchResponse::_internal_set_rid(const std::string& value) {
  
  _impl_.rid_.Set(value, GetArenaForAllocation());
}
inline std::string* NormalMatchResponse::_internal_mutable_rid() {
  
  return _impl_.rid_.Mutable(GetArenaForAllocation());
}
inline std::string* NormalMatchResponse::release_rid() {
  // @@protoc_insertion_point(field_release:GoBang.NormalMatchResponse.rid)
  return _impl_.rid_.Release();
}
inline void NormalMatchResponse::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  _impl_.rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rid_.IsDefault()) {
    _impl_.rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.NormalMatchResponse.rid)
}

// -------------------------------------------------------------------

// RankMatchRequest

// string uid = 1;
inline void RankMatchRequest::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& RankMatchRequest::uid() const {
  // @@protoc_insertion_point(field_get:GoBang.RankMatchRequest.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RankMatchRequest::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.RankMatchRequest.uid)
}
inline std::string* RankMatchRequest::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:GoBang.RankMatchRequest.uid)
  return _s;
}
inline const std::string& RankMatchRequest::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void RankMatchRequest::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* RankMatchRequest::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* RankMatchRequest::release_uid() {
  // @@protoc_insertion_point(field_release:GoBang.RankMatchRequest.uid)
  return _impl_.uid_.Release();
}
inline void RankMatchRequest::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.RankMatchRequest.uid)
}

// -------------------------------------------------------------------

// RankMatchResponse

// bool success = 1;
inline void RankMatchResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool RankMatchResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool RankMatchResponse::success() const {
  // @@protoc_insertion_point(field_get:GoBang.RankMatchResponse.success)
  return _internal_success();
}
inline void RankMatchResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void RankMatchResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:GoBang.RankMatchResponse.success)
}

// string msg = 2;
inline void RankMatchResponse::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& RankMatchResponse::msg() const {
  // @@protoc_insertion_point(field_get:GoBang.RankMatchResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RankMatchResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.RankMatchResponse.msg)
}
inline std::string* RankMatchResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:GoBang.RankMatchResponse.msg)
  return _s;
}
inline const std::string& RankMatchResponse::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void RankMatchResponse::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* RankMatchResponse::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* RankMatchResponse::release_msg() {
  // @@protoc_insertion_point(field_release:GoBang.RankMatchResponse.msg)
  return _impl_.msg_.Release();
}
inline void RankMatchResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.RankMatchResponse.msg)
}

// string rid = 3;
inline void RankMatchResponse::clear_rid() {
  _impl_.rid_.ClearToEmpty();
}
inline const std::string& RankMatchResponse::rid() const {
  // @@protoc_insertion_point(field_get:GoBang.RankMatchResponse.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RankMatchResponse::set_rid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.RankMatchResponse.rid)
}
inline std::string* RankMatchResponse::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:GoBang.RankMatchResponse.rid)
  return _s;
}
inline const std::string& RankMatchResponse::_internal_rid() const {
  return _impl_.rid_.Get();
}
inline void RankMatchResponse::_internal_set_rid(const std::string& value) {
  
  _impl_.rid_.Set(value, GetArenaForAllocation());
}
inline std::string* RankMatchResponse::_internal_mutable_rid() {
  
  return _impl_.rid_.Mutable(GetArenaForAllocation());
}
inline std::string* RankMatchResponse::release_rid() {
  // @@protoc_insertion_point(field_release:GoBang.RankMatchResponse.rid)
  return _impl_.rid_.Release();
}
inline void RankMatchResponse::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  _impl_.rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rid_.IsDefault()) {
    _impl_.rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.RankMatchResponse.rid)
}

// -------------------------------------------------------------------

// CreateRoomRequest

// string uid = 1;
inline void CreateRoomRequest::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& CreateRoomRequest::uid() const {
  // @@protoc_insertion_point(field_get:GoBang.CreateRoomRequest.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRoomRequest::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.CreateRoomRequest.uid)
}
inline std::string* CreateRoomRequest::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:GoBang.CreateRoomRequest.uid)
  return _s;
}
inline const std::string& CreateRoomRequest::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void CreateRoomRequest::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRoomRequest::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRoomRequest::release_uid() {
  // @@protoc_insertion_point(field_release:GoBang.CreateRoomRequest.uid)
  return _impl_.uid_.Release();
}
inline void CreateRoomRequest::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.CreateRoomRequest.uid)
}

// -------------------------------------------------------------------

// CreateRoomResponse

// bool success = 1;
inline void CreateRoomResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool CreateRoomResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool CreateRoomResponse::success() const {
  // @@protoc_insertion_point(field_get:GoBang.CreateRoomResponse.success)
  return _internal_success();
}
inline void CreateRoomResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void CreateRoomResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:GoBang.CreateRoomResponse.success)
}

// string msg = 2;
inline void CreateRoomResponse::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& CreateRoomResponse::msg() const {
  // @@protoc_insertion_point(field_get:GoBang.CreateRoomResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRoomResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.CreateRoomResponse.msg)
}
inline std::string* CreateRoomResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:GoBang.CreateRoomResponse.msg)
  return _s;
}
inline const std::string& CreateRoomResponse::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void CreateRoomResponse::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRoomResponse::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRoomResponse::release_msg() {
  // @@protoc_insertion_point(field_release:GoBang.CreateRoomResponse.msg)
  return _impl_.msg_.Release();
}
inline void CreateRoomResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.CreateRoomResponse.msg)
}

// string rid = 3;
inline void CreateRoomResponse::clear_rid() {
  _impl_.rid_.ClearToEmpty();
}
inline const std::string& CreateRoomResponse::rid() const {
  // @@protoc_insertion_point(field_get:GoBang.CreateRoomResponse.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateRoomResponse::set_rid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.CreateRoomResponse.rid)
}
inline std::string* CreateRoomResponse::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:GoBang.CreateRoomResponse.rid)
  return _s;
}
inline const std::string& CreateRoomResponse::_internal_rid() const {
  return _impl_.rid_.Get();
}
inline void CreateRoomResponse::_internal_set_rid(const std::string& value) {
  
  _impl_.rid_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateRoomResponse::_internal_mutable_rid() {
  
  return _impl_.rid_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateRoomResponse::release_rid() {
  // @@protoc_insertion_point(field_release:GoBang.CreateRoomResponse.rid)
  return _impl_.rid_.Release();
}
inline void CreateRoomResponse::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  _impl_.rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rid_.IsDefault()) {
    _impl_.rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.CreateRoomResponse.rid)
}

// -------------------------------------------------------------------

// JoinRoomRequest

// string uid = 1;
inline void JoinRoomRequest::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& JoinRoomRequest::uid() const {
  // @@protoc_insertion_point(field_get:GoBang.JoinRoomRequest.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinRoomRequest::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.JoinRoomRequest.uid)
}
inline std::string* JoinRoomRequest::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:GoBang.JoinRoomRequest.uid)
  return _s;
}
inline const std::string& JoinRoomRequest::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void JoinRoomRequest::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinRoomRequest::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinRoomRequest::release_uid() {
  // @@protoc_insertion_point(field_release:GoBang.JoinRoomRequest.uid)
  return _impl_.uid_.Release();
}
inline void JoinRoomRequest::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.JoinRoomRequest.uid)
}

// string rid = 2;
inline void JoinRoomRequest::clear_rid() {
  _impl_.rid_.ClearToEmpty();
}
inline const std::string& JoinRoomRequest::rid() const {
  // @@protoc_insertion_point(field_get:GoBang.JoinRoomRequest.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinRoomRequest::set_rid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.JoinRoomRequest.rid)
}
inline std::string* JoinRoomRequest::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:GoBang.JoinRoomRequest.rid)
  return _s;
}
inline const std::string& JoinRoomRequest::_internal_rid() const {
  return _impl_.rid_.Get();
}
inline void JoinRoomRequest::_internal_set_rid(const std::string& value) {
  
  _impl_.rid_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinRoomRequest::_internal_mutable_rid() {
  
  return _impl_.rid_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinRoomRequest::release_rid() {
  // @@protoc_insertion_point(field_release:GoBang.JoinRoomRequest.rid)
  return _impl_.rid_.Release();
}
inline void JoinRoomRequest::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  _impl_.rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rid_.IsDefault()) {
    _impl_.rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.JoinRoomRequest.rid)
}

// -------------------------------------------------------------------

// JoinRoomResponse

// bool success = 1;
inline void JoinRoomResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool JoinRoomResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool JoinRoomResponse::success() const {
  // @@protoc_insertion_point(field_get:GoBang.JoinRoomResponse.success)
  return _internal_success();
}
inline void JoinRoomResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void JoinRoomResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:GoBang.JoinRoomResponse.success)
}

// string msg = 2;
inline void JoinRoomResponse::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& JoinRoomResponse::msg() const {
  // @@protoc_insertion_point(field_get:GoBang.JoinRoomResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinRoomResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.JoinRoomResponse.msg)
}
inline std::string* JoinRoomResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:GoBang.JoinRoomResponse.msg)
  return _s;
}
inline const std::string& JoinRoomResponse::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void JoinRoomResponse::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinRoomResponse::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinRoomResponse::release_msg() {
  // @@protoc_insertion_point(field_release:GoBang.JoinRoomResponse.msg)
  return _impl_.msg_.Release();
}
inline void JoinRoomResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.JoinRoomResponse.msg)
}

// string rid = 3;
inline void JoinRoomResponse::clear_rid() {
  _impl_.rid_.ClearToEmpty();
}
inline const std::string& JoinRoomResponse::rid() const {
  // @@protoc_insertion_point(field_get:GoBang.JoinRoomResponse.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JoinRoomResponse::set_rid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.JoinRoomResponse.rid)
}
inline std::string* JoinRoomResponse::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:GoBang.JoinRoomResponse.rid)
  return _s;
}
inline const std::string& JoinRoomResponse::_internal_rid() const {
  return _impl_.rid_.Get();
}
inline void JoinRoomResponse::_internal_set_rid(const std::string& value) {
  
  _impl_.rid_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinRoomResponse::_internal_mutable_rid() {
  
  return _impl_.rid_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinRoomResponse::release_rid() {
  // @@protoc_insertion_point(field_release:GoBang.JoinRoomResponse.rid)
  return _impl_.rid_.Release();
}
inline void JoinRoomResponse::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  _impl_.rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rid_.IsDefault()) {
    _impl_.rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.JoinRoomResponse.rid)
}

// -------------------------------------------------------------------

// Piece

// int32 x = 1;
inline void Piece::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t Piece::_internal_x() const {
  return _impl_.x_;
}
inline int32_t Piece::x() const {
  // @@protoc_insertion_point(field_get:GoBang.Piece.x)
  return _internal_x();
}
inline void Piece::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void Piece::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:GoBang.Piece.x)
}

// int32 y = 2;
inline void Piece::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t Piece::_internal_y() const {
  return _impl_.y_;
}
inline int32_t Piece::y() const {
  // @@protoc_insertion_point(field_get:GoBang.Piece.y)
  return _internal_y();
}
inline void Piece::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void Piece::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:GoBang.Piece.y)
}

// .GoBang.PieceColor color = 3;
inline void Piece::clear_color() {
  _impl_.color_ = 0;
}
inline ::GoBang::PieceColor Piece::_internal_color() const {
  return static_cast< ::GoBang::PieceColor >(_impl_.color_);
}
inline ::GoBang::PieceColor Piece::color() const {
  // @@protoc_insertion_point(field_get:GoBang.Piece.color)
  return _internal_color();
}
inline void Piece::_internal_set_color(::GoBang::PieceColor value) {
  
  _impl_.color_ = value;
}
inline void Piece::set_color(::GoBang::PieceColor value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:GoBang.Piece.color)
}

// -------------------------------------------------------------------

// Border

// sfixed64 row_2 = 1;
inline void Border::clear_row_2() {
  _impl_.row_2_ = int64_t{0};
}
inline int64_t Border::_internal_row_2() const {
  return _impl_.row_2_;
}
inline int64_t Border::row_2() const {
  // @@protoc_insertion_point(field_get:GoBang.Border.row_2)
  return _internal_row_2();
}
inline void Border::_internal_set_row_2(int64_t value) {
  
  _impl_.row_2_ = value;
}
inline void Border::set_row_2(int64_t value) {
  _internal_set_row_2(value);
  // @@protoc_insertion_point(field_set:GoBang.Border.row_2)
}

// sfixed64 row_4 = 2;
inline void Border::clear_row_4() {
  _impl_.row_4_ = int64_t{0};
}
inline int64_t Border::_internal_row_4() const {
  return _impl_.row_4_;
}
inline int64_t Border::row_4() const {
  // @@protoc_insertion_point(field_get:GoBang.Border.row_4)
  return _internal_row_4();
}
inline void Border::_internal_set_row_4(int64_t value) {
  
  _impl_.row_4_ = value;
}
inline void Border::set_row_4(int64_t value) {
  _internal_set_row_4(value);
  // @@protoc_insertion_point(field_set:GoBang.Border.row_4)
}

// sfixed64 row_6 = 3;
inline void Border::clear_row_6() {
  _impl_.row_6_ = int64_t{0};
}
inline int64_t Border::_internal_row_6() const {
  return _impl_.row_6_;
}
inline int64_t Border::row_6() const {
  // @@protoc_insertion_point(field_get:GoBang.Border.row_6)
  return _internal_row_6();
}
inline void Border::_internal_set_row_6(int64_t value) {
  
  _impl_.row_6_ = value;
}
inline void Border::set_row_6(int64_t value) {
  _internal_set_row_6(value);
  // @@protoc_insertion_point(field_set:GoBang.Border.row_6)
}

// sfixed64 row_8 = 4;
inline void Border::clear_row_8() {
  _impl_.row_8_ = int64_t{0};
}
inline int64_t Border::_internal_row_8() const {
  return _impl_.row_8_;
}
inline int64_t Border::row_8() const {
  // @@protoc_insertion_point(field_get:GoBang.Border.row_8)
  return _internal_row_8();
}
inline void Border::_internal_set_row_8(int64_t value) {
  
  _impl_.row_8_ = value;
}
inline void Border::set_row_8(int64_t value) {
  _internal_set_row_8(value);
  // @@protoc_insertion_point(field_set:GoBang.Border.row_8)
}

// sfixed64 row_10 = 5;
inline void Border::clear_row_10() {
  _impl_.row_10_ = int64_t{0};
}
inline int64_t Border::_internal_row_10() const {
  return _impl_.row_10_;
}
inline int64_t Border::row_10() const {
  // @@protoc_insertion_point(field_get:GoBang.Border.row_10)
  return _internal_row_10();
}
inline void Border::_internal_set_row_10(int64_t value) {
  
  _impl_.row_10_ = value;
}
inline void Border::set_row_10(int64_t value) {
  _internal_set_row_10(value);
  // @@protoc_insertion_point(field_set:GoBang.Border.row_10)
}

// sfixed64 row_12 = 6;
inline void Border::clear_row_12() {
  _impl_.row_12_ = int64_t{0};
}
inline int64_t Border::_internal_row_12() const {
  return _impl_.row_12_;
}
inline int64_t Border::row_12() const {
  // @@protoc_insertion_point(field_get:GoBang.Border.row_12)
  return _internal_row_12();
}
inline void Border::_internal_set_row_12(int64_t value) {
  
  _impl_.row_12_ = value;
}
inline void Border::set_row_12(int64_t value) {
  _internal_set_row_12(value);
  // @@protoc_insertion_point(field_set:GoBang.Border.row_12)
}

// sfixed64 row_14 = 7;
inline void Border::clear_row_14() {
  _impl_.row_14_ = int64_t{0};
}
inline int64_t Border::_internal_row_14() const {
  return _impl_.row_14_;
}
inline int64_t Border::row_14() const {
  // @@protoc_insertion_point(field_get:GoBang.Border.row_14)
  return _internal_row_14();
}
inline void Border::_internal_set_row_14(int64_t value) {
  
  _impl_.row_14_ = value;
}
inline void Border::set_row_14(int64_t value) {
  _internal_set_row_14(value);
  // @@protoc_insertion_point(field_set:GoBang.Border.row_14)
}

// sfixed64 row_16 = 8;
inline void Border::clear_row_16() {
  _impl_.row_16_ = int64_t{0};
}
inline int64_t Border::_internal_row_16() const {
  return _impl_.row_16_;
}
inline int64_t Border::row_16() const {
  // @@protoc_insertion_point(field_get:GoBang.Border.row_16)
  return _internal_row_16();
}
inline void Border::_internal_set_row_16(int64_t value) {
  
  _impl_.row_16_ = value;
}
inline void Border::set_row_16(int64_t value) {
  _internal_set_row_16(value);
  // @@protoc_insertion_point(field_set:GoBang.Border.row_16)
}

// -------------------------------------------------------------------

// SetPieceRequest

// .GoBang.Piece p = 1;
inline bool SetPieceRequest::_internal_has_p() const {
  return this != internal_default_instance() && _impl_.p_ != nullptr;
}
inline bool SetPieceRequest::has_p() const {
  return _internal_has_p();
}
inline void SetPieceRequest::clear_p() {
  if (GetArenaForAllocation() == nullptr && _impl_.p_ != nullptr) {
    delete _impl_.p_;
  }
  _impl_.p_ = nullptr;
}
inline const ::GoBang::Piece& SetPieceRequest::_internal_p() const {
  const ::GoBang::Piece* p = _impl_.p_;
  return p != nullptr ? *p : reinterpret_cast<const ::GoBang::Piece&>(
      ::GoBang::_Piece_default_instance_);
}
inline const ::GoBang::Piece& SetPieceRequest::p() const {
  // @@protoc_insertion_point(field_get:GoBang.SetPieceRequest.p)
  return _internal_p();
}
inline void SetPieceRequest::unsafe_arena_set_allocated_p(
    ::GoBang::Piece* p) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.p_);
  }
  _impl_.p_ = p;
  if (p) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.SetPieceRequest.p)
}
inline ::GoBang::Piece* SetPieceRequest::release_p() {
  
  ::GoBang::Piece* temp = _impl_.p_;
  _impl_.p_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GoBang::Piece* SetPieceRequest::unsafe_arena_release_p() {
  // @@protoc_insertion_point(field_release:GoBang.SetPieceRequest.p)
  
  ::GoBang::Piece* temp = _impl_.p_;
  _impl_.p_ = nullptr;
  return temp;
}
inline ::GoBang::Piece* SetPieceRequest::_internal_mutable_p() {
  
  if (_impl_.p_ == nullptr) {
    auto* p = CreateMaybeMessage<::GoBang::Piece>(GetArenaForAllocation());
    _impl_.p_ = p;
  }
  return _impl_.p_;
}
inline ::GoBang::Piece* SetPieceRequest::mutable_p() {
  ::GoBang::Piece* _msg = _internal_mutable_p();
  // @@protoc_insertion_point(field_mutable:GoBang.SetPieceRequest.p)
  return _msg;
}
inline void SetPieceRequest::set_allocated_p(::GoBang::Piece* p) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.p_;
  }
  if (p) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(p);
    if (message_arena != submessage_arena) {
      p = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.p_ = p;
  // @@protoc_insertion_point(field_set_allocated:GoBang.SetPieceRequest.p)
}

// -------------------------------------------------------------------

// SetPieceResponse

// bool success = 1;
inline void SetPieceResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool SetPieceResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool SetPieceResponse::success() const {
  // @@protoc_insertion_point(field_get:GoBang.SetPieceResponse.success)
  return _internal_success();
}
inline void SetPieceResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void SetPieceResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:GoBang.SetPieceResponse.success)
}

// .GoBang.PieceColor next = 4;
inline void SetPieceResponse::clear_next() {
  _impl_.next_ = 0;
}
inline ::GoBang::PieceColor SetPieceResponse::_internal_next() const {
  return static_cast< ::GoBang::PieceColor >(_impl_.next_);
}
inline ::GoBang::PieceColor SetPieceResponse::next() const {
  // @@protoc_insertion_point(field_get:GoBang.SetPieceResponse.next)
  return _internal_next();
}
inline void SetPieceResponse::_internal_set_next(::GoBang::PieceColor value) {
  
  _impl_.next_ = value;
}
inline void SetPieceResponse::set_next(::GoBang::PieceColor value) {
  _internal_set_next(value);
  // @@protoc_insertion_point(field_set:GoBang.SetPieceResponse.next)
}

// string msg = 2;
inline void SetPieceResponse::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& SetPieceResponse::msg() const {
  // @@protoc_insertion_point(field_get:GoBang.SetPieceResponse.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetPieceResponse::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.SetPieceResponse.msg)
}
inline std::string* SetPieceResponse::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:GoBang.SetPieceResponse.msg)
  return _s;
}
inline const std::string& SetPieceResponse::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void SetPieceResponse::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* SetPieceResponse::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* SetPieceResponse::release_msg() {
  // @@protoc_insertion_point(field_release:GoBang.SetPieceResponse.msg)
  return _impl_.msg_.Release();
}
inline void SetPieceResponse::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.SetPieceResponse.msg)
}

// .GoBang.Border b = 3;
inline bool SetPieceResponse::_internal_has_b() const {
  return this != internal_default_instance() && _impl_.b_ != nullptr;
}
inline bool SetPieceResponse::has_b() const {
  return _internal_has_b();
}
inline void SetPieceResponse::clear_b() {
  if (GetArenaForAllocation() == nullptr && _impl_.b_ != nullptr) {
    delete _impl_.b_;
  }
  _impl_.b_ = nullptr;
}
inline const ::GoBang::Border& SetPieceResponse::_internal_b() const {
  const ::GoBang::Border* p = _impl_.b_;
  return p != nullptr ? *p : reinterpret_cast<const ::GoBang::Border&>(
      ::GoBang::_Border_default_instance_);
}
inline const ::GoBang::Border& SetPieceResponse::b() const {
  // @@protoc_insertion_point(field_get:GoBang.SetPieceResponse.b)
  return _internal_b();
}
inline void SetPieceResponse::unsafe_arena_set_allocated_b(
    ::GoBang::Border* b) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.b_);
  }
  _impl_.b_ = b;
  if (b) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.SetPieceResponse.b)
}
inline ::GoBang::Border* SetPieceResponse::release_b() {
  
  ::GoBang::Border* temp = _impl_.b_;
  _impl_.b_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GoBang::Border* SetPieceResponse::unsafe_arena_release_b() {
  // @@protoc_insertion_point(field_release:GoBang.SetPieceResponse.b)
  
  ::GoBang::Border* temp = _impl_.b_;
  _impl_.b_ = nullptr;
  return temp;
}
inline ::GoBang::Border* SetPieceResponse::_internal_mutable_b() {
  
  if (_impl_.b_ == nullptr) {
    auto* p = CreateMaybeMessage<::GoBang::Border>(GetArenaForAllocation());
    _impl_.b_ = p;
  }
  return _impl_.b_;
}
inline ::GoBang::Border* SetPieceResponse::mutable_b() {
  ::GoBang::Border* _msg = _internal_mutable_b();
  // @@protoc_insertion_point(field_mutable:GoBang.SetPieceResponse.b)
  return _msg;
}
inline void SetPieceResponse::set_allocated_b(::GoBang::Border* b) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.b_;
  }
  if (b) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(b);
    if (message_arena != submessage_arena) {
      b = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, b, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.b_ = b;
  // @@protoc_insertion_point(field_set_allocated:GoBang.SetPieceResponse.b)
}

// -------------------------------------------------------------------

// UndoRequest

// string uid = 1;
inline void UndoRequest::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& UndoRequest::uid() const {
  // @@protoc_insertion_point(field_get:GoBang.UndoRequest.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UndoRequest::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.UndoRequest.uid)
}
inline std::string* UndoRequest::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:GoBang.UndoRequest.uid)
  return _s;
}
inline const std::string& UndoRequest::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void UndoRequest::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* UndoRequest::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* UndoRequest::release_uid() {
  // @@protoc_insertion_point(field_release:GoBang.UndoRequest.uid)
  return _impl_.uid_.Release();
}
inline void UndoRequest::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.UndoRequest.uid)
}

// -------------------------------------------------------------------

// UndoResponse

// bool success = 1;
inline void UndoResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool UndoResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool UndoResponse::success() const {
  // @@protoc_insertion_point(field_get:GoBang.UndoResponse.success)
  return _internal_success();
}
inline void UndoResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void UndoResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:GoBang.UndoResponse.success)
}

// -------------------------------------------------------------------

// TieRequest

// string uid = 1;
inline void TieRequest::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& TieRequest::uid() const {
  // @@protoc_insertion_point(field_get:GoBang.TieRequest.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TieRequest::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.TieRequest.uid)
}
inline std::string* TieRequest::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:GoBang.TieRequest.uid)
  return _s;
}
inline const std::string& TieRequest::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void TieRequest::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* TieRequest::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* TieRequest::release_uid() {
  // @@protoc_insertion_point(field_release:GoBang.TieRequest.uid)
  return _impl_.uid_.Release();
}
inline void TieRequest::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.TieRequest.uid)
}

// -------------------------------------------------------------------

// TieResponse

// bool success = 1;
inline void TieResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool TieResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool TieResponse::success() const {
  // @@protoc_insertion_point(field_get:GoBang.TieResponse.success)
  return _internal_success();
}
inline void TieResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void TieResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:GoBang.TieResponse.success)
}

// -------------------------------------------------------------------

// SurrenderRequest

// string uid = 1;
inline void SurrenderRequest::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& SurrenderRequest::uid() const {
  // @@protoc_insertion_point(field_get:GoBang.SurrenderRequest.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SurrenderRequest::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.SurrenderRequest.uid)
}
inline std::string* SurrenderRequest::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:GoBang.SurrenderRequest.uid)
  return _s;
}
inline const std::string& SurrenderRequest::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void SurrenderRequest::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* SurrenderRequest::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* SurrenderRequest::release_uid() {
  // @@protoc_insertion_point(field_release:GoBang.SurrenderRequest.uid)
  return _impl_.uid_.Release();
}
inline void SurrenderRequest::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.SurrenderRequest.uid)
}

// -------------------------------------------------------------------

// Messg

// string name = 1;
inline void Messg::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Messg::name() const {
  // @@protoc_insertion_point(field_get:GoBang.Messg.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Messg::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.Messg.name)
}
inline std::string* Messg::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:GoBang.Messg.name)
  return _s;
}
inline const std::string& Messg::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Messg::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Messg::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Messg::release_name() {
  // @@protoc_insertion_point(field_release:GoBang.Messg.name)
  return _impl_.name_.Release();
}
inline void Messg::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.Messg.name)
}

// string msg = 2;
inline void Messg::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& Messg::msg() const {
  // @@protoc_insertion_point(field_get:GoBang.Messg.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Messg::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.Messg.msg)
}
inline std::string* Messg::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:GoBang.Messg.msg)
  return _s;
}
inline const std::string& Messg::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void Messg::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* Messg::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* Messg::release_msg() {
  // @@protoc_insertion_point(field_release:GoBang.Messg.msg)
  return _impl_.msg_.Release();
}
inline void Messg::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.Messg.msg)
}

// -------------------------------------------------------------------

// ContinueGameRequest

// string uid = 1;
inline void ContinueGameRequest::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& ContinueGameRequest::uid() const {
  // @@protoc_insertion_point(field_get:GoBang.ContinueGameRequest.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContinueGameRequest::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.ContinueGameRequest.uid)
}
inline std::string* ContinueGameRequest::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:GoBang.ContinueGameRequest.uid)
  return _s;
}
inline const std::string& ContinueGameRequest::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void ContinueGameRequest::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* ContinueGameRequest::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* ContinueGameRequest::release_uid() {
  // @@protoc_insertion_point(field_release:GoBang.ContinueGameRequest.uid)
  return _impl_.uid_.Release();
}
inline void ContinueGameRequest::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.ContinueGameRequest.uid)
}

// -------------------------------------------------------------------

// ContinueGameResponse

// -------------------------------------------------------------------

// QuitRoomRequest

// string uid = 1;
inline void QuitRoomRequest::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& QuitRoomRequest::uid() const {
  // @@protoc_insertion_point(field_get:GoBang.QuitRoomRequest.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QuitRoomRequest::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.QuitRoomRequest.uid)
}
inline std::string* QuitRoomRequest::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:GoBang.QuitRoomRequest.uid)
  return _s;
}
inline const std::string& QuitRoomRequest::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void QuitRoomRequest::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* QuitRoomRequest::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* QuitRoomRequest::release_uid() {
  // @@protoc_insertion_point(field_release:GoBang.QuitRoomRequest.uid)
  return _impl_.uid_.Release();
}
inline void QuitRoomRequest::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.QuitRoomRequest.uid)
}

// -------------------------------------------------------------------

// QuitRoomResponse

// string uid = 1;
inline void QuitRoomResponse::clear_uid() {
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& QuitRoomResponse::uid() const {
  // @@protoc_insertion_point(field_get:GoBang.QuitRoomResponse.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QuitRoomResponse::set_uid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.QuitRoomResponse.uid)
}
inline std::string* QuitRoomResponse::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:GoBang.QuitRoomResponse.uid)
  return _s;
}
inline const std::string& QuitRoomResponse::_internal_uid() const {
  return _impl_.uid_.Get();
}
inline void QuitRoomResponse::_internal_set_uid(const std::string& value) {
  
  _impl_.uid_.Set(value, GetArenaForAllocation());
}
inline std::string* QuitRoomResponse::_internal_mutable_uid() {
  
  return _impl_.uid_.Mutable(GetArenaForAllocation());
}
inline std::string* QuitRoomResponse::release_uid() {
  // @@protoc_insertion_point(field_release:GoBang.QuitRoomResponse.uid)
  return _impl_.uid_.Release();
}
inline void QuitRoomResponse::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  _impl_.uid_.SetAllocated(uid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uid_.IsDefault()) {
    _impl_.uid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.QuitRoomResponse.uid)
}

// -------------------------------------------------------------------

// GameStart

// .GoBang.PieceColor myColor = 1;
inline void GameStart::clear_mycolor() {
  _impl_.mycolor_ = 0;
}
inline ::GoBang::PieceColor GameStart::_internal_mycolor() const {
  return static_cast< ::GoBang::PieceColor >(_impl_.mycolor_);
}
inline ::GoBang::PieceColor GameStart::mycolor() const {
  // @@protoc_insertion_point(field_get:GoBang.GameStart.myColor)
  return _internal_mycolor();
}
inline void GameStart::_internal_set_mycolor(::GoBang::PieceColor value) {
  
  _impl_.mycolor_ = value;
}
inline void GameStart::set_mycolor(::GoBang::PieceColor value) {
  _internal_set_mycolor(value);
  // @@protoc_insertion_point(field_set:GoBang.GameStart.myColor)
}

// .GoBang.PieceColor competitorColor = 2;
inline void GameStart::clear_competitorcolor() {
  _impl_.competitorcolor_ = 0;
}
inline ::GoBang::PieceColor GameStart::_internal_competitorcolor() const {
  return static_cast< ::GoBang::PieceColor >(_impl_.competitorcolor_);
}
inline ::GoBang::PieceColor GameStart::competitorcolor() const {
  // @@protoc_insertion_point(field_get:GoBang.GameStart.competitorColor)
  return _internal_competitorcolor();
}
inline void GameStart::_internal_set_competitorcolor(::GoBang::PieceColor value) {
  
  _impl_.competitorcolor_ = value;
}
inline void GameStart::set_competitorcolor(::GoBang::PieceColor value) {
  _internal_set_competitorcolor(value);
  // @@protoc_insertion_point(field_set:GoBang.GameStart.competitorColor)
}

// string competitorName = 3;
inline void GameStart::clear_competitorname() {
  _impl_.competitorname_.ClearToEmpty();
}
inline const std::string& GameStart::competitorname() const {
  // @@protoc_insertion_point(field_get:GoBang.GameStart.competitorName)
  return _internal_competitorname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameStart::set_competitorname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.competitorname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.GameStart.competitorName)
}
inline std::string* GameStart::mutable_competitorname() {
  std::string* _s = _internal_mutable_competitorname();
  // @@protoc_insertion_point(field_mutable:GoBang.GameStart.competitorName)
  return _s;
}
inline const std::string& GameStart::_internal_competitorname() const {
  return _impl_.competitorname_.Get();
}
inline void GameStart::_internal_set_competitorname(const std::string& value) {
  
  _impl_.competitorname_.Set(value, GetArenaForAllocation());
}
inline std::string* GameStart::_internal_mutable_competitorname() {
  
  return _impl_.competitorname_.Mutable(GetArenaForAllocation());
}
inline std::string* GameStart::release_competitorname() {
  // @@protoc_insertion_point(field_release:GoBang.GameStart.competitorName)
  return _impl_.competitorname_.Release();
}
inline void GameStart::set_allocated_competitorname(std::string* competitorname) {
  if (competitorname != nullptr) {
    
  } else {
    
  }
  _impl_.competitorname_.SetAllocated(competitorname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.competitorname_.IsDefault()) {
    _impl_.competitorname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.GameStart.competitorName)
}

// string competitorID = 4;
inline void GameStart::clear_competitorid() {
  _impl_.competitorid_.ClearToEmpty();
}
inline const std::string& GameStart::competitorid() const {
  // @@protoc_insertion_point(field_get:GoBang.GameStart.competitorID)
  return _internal_competitorid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameStart::set_competitorid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.competitorid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.GameStart.competitorID)
}
inline std::string* GameStart::mutable_competitorid() {
  std::string* _s = _internal_mutable_competitorid();
  // @@protoc_insertion_point(field_mutable:GoBang.GameStart.competitorID)
  return _s;
}
inline const std::string& GameStart::_internal_competitorid() const {
  return _impl_.competitorid_.Get();
}
inline void GameStart::_internal_set_competitorid(const std::string& value) {
  
  _impl_.competitorid_.Set(value, GetArenaForAllocation());
}
inline std::string* GameStart::_internal_mutable_competitorid() {
  
  return _impl_.competitorid_.Mutable(GetArenaForAllocation());
}
inline std::string* GameStart::release_competitorid() {
  // @@protoc_insertion_point(field_release:GoBang.GameStart.competitorID)
  return _impl_.competitorid_.Release();
}
inline void GameStart::set_allocated_competitorid(std::string* competitorid) {
  if (competitorid != nullptr) {
    
  } else {
    
  }
  _impl_.competitorid_.SetAllocated(competitorid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.competitorid_.IsDefault()) {
    _impl_.competitorid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.GameStart.competitorID)
}

// string rid = 5;
inline void GameStart::clear_rid() {
  _impl_.rid_.ClearToEmpty();
}
inline const std::string& GameStart::rid() const {
  // @@protoc_insertion_point(field_get:GoBang.GameStart.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameStart::set_rid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.GameStart.rid)
}
inline std::string* GameStart::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:GoBang.GameStart.rid)
  return _s;
}
inline const std::string& GameStart::_internal_rid() const {
  return _impl_.rid_.Get();
}
inline void GameStart::_internal_set_rid(const std::string& value) {
  
  _impl_.rid_.Set(value, GetArenaForAllocation());
}
inline std::string* GameStart::_internal_mutable_rid() {
  
  return _impl_.rid_.Mutable(GetArenaForAllocation());
}
inline std::string* GameStart::release_rid() {
  // @@protoc_insertion_point(field_release:GoBang.GameStart.rid)
  return _impl_.rid_.Release();
}
inline void GameStart::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  _impl_.rid_.SetAllocated(rid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rid_.IsDefault()) {
    _impl_.rid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.GameStart.rid)
}

// -------------------------------------------------------------------

// GameOver

// bool isWin = 1;
inline void GameOver::clear_iswin() {
  _impl_.iswin_ = false;
}
inline bool GameOver::_internal_iswin() const {
  return _impl_.iswin_;
}
inline bool GameOver::iswin() const {
  // @@protoc_insertion_point(field_get:GoBang.GameOver.isWin)
  return _internal_iswin();
}
inline void GameOver::_internal_set_iswin(bool value) {
  
  _impl_.iswin_ = value;
}
inline void GameOver::set_iswin(bool value) {
  _internal_set_iswin(value);
  // @@protoc_insertion_point(field_set:GoBang.GameOver.isWin)
}

// string winUid = 2;
inline void GameOver::clear_winuid() {
  _impl_.winuid_.ClearToEmpty();
}
inline const std::string& GameOver::winuid() const {
  // @@protoc_insertion_point(field_get:GoBang.GameOver.winUid)
  return _internal_winuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameOver::set_winuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.winuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GoBang.GameOver.winUid)
}
inline std::string* GameOver::mutable_winuid() {
  std::string* _s = _internal_mutable_winuid();
  // @@protoc_insertion_point(field_mutable:GoBang.GameOver.winUid)
  return _s;
}
inline const std::string& GameOver::_internal_winuid() const {
  return _impl_.winuid_.Get();
}
inline void GameOver::_internal_set_winuid(const std::string& value) {
  
  _impl_.winuid_.Set(value, GetArenaForAllocation());
}
inline std::string* GameOver::_internal_mutable_winuid() {
  
  return _impl_.winuid_.Mutable(GetArenaForAllocation());
}
inline std::string* GameOver::release_winuid() {
  // @@protoc_insertion_point(field_release:GoBang.GameOver.winUid)
  return _impl_.winuid_.Release();
}
inline void GameOver::set_allocated_winuid(std::string* winuid) {
  if (winuid != nullptr) {
    
  } else {
    
  }
  _impl_.winuid_.SetAllocated(winuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.winuid_.IsDefault()) {
    _impl_.winuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GoBang.GameOver.winUid)
}

// -------------------------------------------------------------------

// goBangRequest

// .GoBang.TYPE type = 1;
inline void goBangRequest::clear_type() {
  _impl_.type_ = 0;
}
inline ::GoBang::TYPE goBangRequest::_internal_type() const {
  return static_cast< ::GoBang::TYPE >(_impl_.type_);
}
inline ::GoBang::TYPE goBangRequest::type() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangRequest.type)
  return _internal_type();
}
inline void goBangRequest::_internal_set_type(::GoBang::TYPE value) {
  
  _impl_.type_ = value;
}
inline void goBangRequest::set_type(::GoBang::TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:GoBang.goBangRequest.type)
}

// .GoBang.LoginRequest loginReq = 2;
inline bool goBangRequest::_internal_has_loginreq() const {
  return request_case() == kLoginReq;
}
inline bool goBangRequest::has_loginreq() const {
  return _internal_has_loginreq();
}
inline void goBangRequest::set_has_loginreq() {
  _impl_._oneof_case_[0] = kLoginReq;
}
inline void goBangRequest::clear_loginreq() {
  if (_internal_has_loginreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.loginreq_;
    }
    clear_has_request();
  }
}
inline ::GoBang::LoginRequest* goBangRequest::release_loginreq() {
  // @@protoc_insertion_point(field_release:GoBang.goBangRequest.loginReq)
  if (_internal_has_loginreq()) {
    clear_has_request();
    ::GoBang::LoginRequest* temp = _impl_.request_.loginreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.loginreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::LoginRequest& goBangRequest::_internal_loginreq() const {
  return _internal_has_loginreq()
      ? *_impl_.request_.loginreq_
      : reinterpret_cast< ::GoBang::LoginRequest&>(::GoBang::_LoginRequest_default_instance_);
}
inline const ::GoBang::LoginRequest& goBangRequest::loginreq() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangRequest.loginReq)
  return _internal_loginreq();
}
inline ::GoBang::LoginRequest* goBangRequest::unsafe_arena_release_loginreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangRequest.loginReq)
  if (_internal_has_loginreq()) {
    clear_has_request();
    ::GoBang::LoginRequest* temp = _impl_.request_.loginreq_;
    _impl_.request_.loginreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangRequest::unsafe_arena_set_allocated_loginreq(::GoBang::LoginRequest* loginreq) {
  clear_request();
  if (loginreq) {
    set_has_loginreq();
    _impl_.request_.loginreq_ = loginreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangRequest.loginReq)
}
inline ::GoBang::LoginRequest* goBangRequest::_internal_mutable_loginreq() {
  if (!_internal_has_loginreq()) {
    clear_request();
    set_has_loginreq();
    _impl_.request_.loginreq_ = CreateMaybeMessage< ::GoBang::LoginRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.loginreq_;
}
inline ::GoBang::LoginRequest* goBangRequest::mutable_loginreq() {
  ::GoBang::LoginRequest* _msg = _internal_mutable_loginreq();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangRequest.loginReq)
  return _msg;
}

// .GoBang.RegisterRequest RegisterReq = 3;
inline bool goBangRequest::_internal_has_registerreq() const {
  return request_case() == kRegisterReq;
}
inline bool goBangRequest::has_registerreq() const {
  return _internal_has_registerreq();
}
inline void goBangRequest::set_has_registerreq() {
  _impl_._oneof_case_[0] = kRegisterReq;
}
inline void goBangRequest::clear_registerreq() {
  if (_internal_has_registerreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.registerreq_;
    }
    clear_has_request();
  }
}
inline ::GoBang::RegisterRequest* goBangRequest::release_registerreq() {
  // @@protoc_insertion_point(field_release:GoBang.goBangRequest.RegisterReq)
  if (_internal_has_registerreq()) {
    clear_has_request();
    ::GoBang::RegisterRequest* temp = _impl_.request_.registerreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.registerreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::RegisterRequest& goBangRequest::_internal_registerreq() const {
  return _internal_has_registerreq()
      ? *_impl_.request_.registerreq_
      : reinterpret_cast< ::GoBang::RegisterRequest&>(::GoBang::_RegisterRequest_default_instance_);
}
inline const ::GoBang::RegisterRequest& goBangRequest::registerreq() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangRequest.RegisterReq)
  return _internal_registerreq();
}
inline ::GoBang::RegisterRequest* goBangRequest::unsafe_arena_release_registerreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangRequest.RegisterReq)
  if (_internal_has_registerreq()) {
    clear_has_request();
    ::GoBang::RegisterRequest* temp = _impl_.request_.registerreq_;
    _impl_.request_.registerreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangRequest::unsafe_arena_set_allocated_registerreq(::GoBang::RegisterRequest* registerreq) {
  clear_request();
  if (registerreq) {
    set_has_registerreq();
    _impl_.request_.registerreq_ = registerreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangRequest.RegisterReq)
}
inline ::GoBang::RegisterRequest* goBangRequest::_internal_mutable_registerreq() {
  if (!_internal_has_registerreq()) {
    clear_request();
    set_has_registerreq();
    _impl_.request_.registerreq_ = CreateMaybeMessage< ::GoBang::RegisterRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.registerreq_;
}
inline ::GoBang::RegisterRequest* goBangRequest::mutable_registerreq() {
  ::GoBang::RegisterRequest* _msg = _internal_mutable_registerreq();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangRequest.RegisterReq)
  return _msg;
}

// .GoBang.RankListRequest rankListReq = 4;
inline bool goBangRequest::_internal_has_ranklistreq() const {
  return request_case() == kRankListReq;
}
inline bool goBangRequest::has_ranklistreq() const {
  return _internal_has_ranklistreq();
}
inline void goBangRequest::set_has_ranklistreq() {
  _impl_._oneof_case_[0] = kRankListReq;
}
inline void goBangRequest::clear_ranklistreq() {
  if (_internal_has_ranklistreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.ranklistreq_;
    }
    clear_has_request();
  }
}
inline ::GoBang::RankListRequest* goBangRequest::release_ranklistreq() {
  // @@protoc_insertion_point(field_release:GoBang.goBangRequest.rankListReq)
  if (_internal_has_ranklistreq()) {
    clear_has_request();
    ::GoBang::RankListRequest* temp = _impl_.request_.ranklistreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.ranklistreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::RankListRequest& goBangRequest::_internal_ranklistreq() const {
  return _internal_has_ranklistreq()
      ? *_impl_.request_.ranklistreq_
      : reinterpret_cast< ::GoBang::RankListRequest&>(::GoBang::_RankListRequest_default_instance_);
}
inline const ::GoBang::RankListRequest& goBangRequest::ranklistreq() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangRequest.rankListReq)
  return _internal_ranklistreq();
}
inline ::GoBang::RankListRequest* goBangRequest::unsafe_arena_release_ranklistreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangRequest.rankListReq)
  if (_internal_has_ranklistreq()) {
    clear_has_request();
    ::GoBang::RankListRequest* temp = _impl_.request_.ranklistreq_;
    _impl_.request_.ranklistreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangRequest::unsafe_arena_set_allocated_ranklistreq(::GoBang::RankListRequest* ranklistreq) {
  clear_request();
  if (ranklistreq) {
    set_has_ranklistreq();
    _impl_.request_.ranklistreq_ = ranklistreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangRequest.rankListReq)
}
inline ::GoBang::RankListRequest* goBangRequest::_internal_mutable_ranklistreq() {
  if (!_internal_has_ranklistreq()) {
    clear_request();
    set_has_ranklistreq();
    _impl_.request_.ranklistreq_ = CreateMaybeMessage< ::GoBang::RankListRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.ranklistreq_;
}
inline ::GoBang::RankListRequest* goBangRequest::mutable_ranklistreq() {
  ::GoBang::RankListRequest* _msg = _internal_mutable_ranklistreq();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangRequest.rankListReq)
  return _msg;
}

// .GoBang.CreateRoomRequest createRoomReq = 5;
inline bool goBangRequest::_internal_has_createroomreq() const {
  return request_case() == kCreateRoomReq;
}
inline bool goBangRequest::has_createroomreq() const {
  return _internal_has_createroomreq();
}
inline void goBangRequest::set_has_createroomreq() {
  _impl_._oneof_case_[0] = kCreateRoomReq;
}
inline void goBangRequest::clear_createroomreq() {
  if (_internal_has_createroomreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.createroomreq_;
    }
    clear_has_request();
  }
}
inline ::GoBang::CreateRoomRequest* goBangRequest::release_createroomreq() {
  // @@protoc_insertion_point(field_release:GoBang.goBangRequest.createRoomReq)
  if (_internal_has_createroomreq()) {
    clear_has_request();
    ::GoBang::CreateRoomRequest* temp = _impl_.request_.createroomreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.createroomreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::CreateRoomRequest& goBangRequest::_internal_createroomreq() const {
  return _internal_has_createroomreq()
      ? *_impl_.request_.createroomreq_
      : reinterpret_cast< ::GoBang::CreateRoomRequest&>(::GoBang::_CreateRoomRequest_default_instance_);
}
inline const ::GoBang::CreateRoomRequest& goBangRequest::createroomreq() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangRequest.createRoomReq)
  return _internal_createroomreq();
}
inline ::GoBang::CreateRoomRequest* goBangRequest::unsafe_arena_release_createroomreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangRequest.createRoomReq)
  if (_internal_has_createroomreq()) {
    clear_has_request();
    ::GoBang::CreateRoomRequest* temp = _impl_.request_.createroomreq_;
    _impl_.request_.createroomreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangRequest::unsafe_arena_set_allocated_createroomreq(::GoBang::CreateRoomRequest* createroomreq) {
  clear_request();
  if (createroomreq) {
    set_has_createroomreq();
    _impl_.request_.createroomreq_ = createroomreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangRequest.createRoomReq)
}
inline ::GoBang::CreateRoomRequest* goBangRequest::_internal_mutable_createroomreq() {
  if (!_internal_has_createroomreq()) {
    clear_request();
    set_has_createroomreq();
    _impl_.request_.createroomreq_ = CreateMaybeMessage< ::GoBang::CreateRoomRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.createroomreq_;
}
inline ::GoBang::CreateRoomRequest* goBangRequest::mutable_createroomreq() {
  ::GoBang::CreateRoomRequest* _msg = _internal_mutable_createroomreq();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangRequest.createRoomReq)
  return _msg;
}

// .GoBang.SetPieceRequest setPieceReq = 6;
inline bool goBangRequest::_internal_has_setpiecereq() const {
  return request_case() == kSetPieceReq;
}
inline bool goBangRequest::has_setpiecereq() const {
  return _internal_has_setpiecereq();
}
inline void goBangRequest::set_has_setpiecereq() {
  _impl_._oneof_case_[0] = kSetPieceReq;
}
inline void goBangRequest::clear_setpiecereq() {
  if (_internal_has_setpiecereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.setpiecereq_;
    }
    clear_has_request();
  }
}
inline ::GoBang::SetPieceRequest* goBangRequest::release_setpiecereq() {
  // @@protoc_insertion_point(field_release:GoBang.goBangRequest.setPieceReq)
  if (_internal_has_setpiecereq()) {
    clear_has_request();
    ::GoBang::SetPieceRequest* temp = _impl_.request_.setpiecereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.setpiecereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::SetPieceRequest& goBangRequest::_internal_setpiecereq() const {
  return _internal_has_setpiecereq()
      ? *_impl_.request_.setpiecereq_
      : reinterpret_cast< ::GoBang::SetPieceRequest&>(::GoBang::_SetPieceRequest_default_instance_);
}
inline const ::GoBang::SetPieceRequest& goBangRequest::setpiecereq() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangRequest.setPieceReq)
  return _internal_setpiecereq();
}
inline ::GoBang::SetPieceRequest* goBangRequest::unsafe_arena_release_setpiecereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangRequest.setPieceReq)
  if (_internal_has_setpiecereq()) {
    clear_has_request();
    ::GoBang::SetPieceRequest* temp = _impl_.request_.setpiecereq_;
    _impl_.request_.setpiecereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangRequest::unsafe_arena_set_allocated_setpiecereq(::GoBang::SetPieceRequest* setpiecereq) {
  clear_request();
  if (setpiecereq) {
    set_has_setpiecereq();
    _impl_.request_.setpiecereq_ = setpiecereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangRequest.setPieceReq)
}
inline ::GoBang::SetPieceRequest* goBangRequest::_internal_mutable_setpiecereq() {
  if (!_internal_has_setpiecereq()) {
    clear_request();
    set_has_setpiecereq();
    _impl_.request_.setpiecereq_ = CreateMaybeMessage< ::GoBang::SetPieceRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.setpiecereq_;
}
inline ::GoBang::SetPieceRequest* goBangRequest::mutable_setpiecereq() {
  ::GoBang::SetPieceRequest* _msg = _internal_mutable_setpiecereq();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangRequest.setPieceReq)
  return _msg;
}

// .GoBang.UndoRequest undoReq = 7;
inline bool goBangRequest::_internal_has_undoreq() const {
  return request_case() == kUndoReq;
}
inline bool goBangRequest::has_undoreq() const {
  return _internal_has_undoreq();
}
inline void goBangRequest::set_has_undoreq() {
  _impl_._oneof_case_[0] = kUndoReq;
}
inline void goBangRequest::clear_undoreq() {
  if (_internal_has_undoreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.undoreq_;
    }
    clear_has_request();
  }
}
inline ::GoBang::UndoRequest* goBangRequest::release_undoreq() {
  // @@protoc_insertion_point(field_release:GoBang.goBangRequest.undoReq)
  if (_internal_has_undoreq()) {
    clear_has_request();
    ::GoBang::UndoRequest* temp = _impl_.request_.undoreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.undoreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::UndoRequest& goBangRequest::_internal_undoreq() const {
  return _internal_has_undoreq()
      ? *_impl_.request_.undoreq_
      : reinterpret_cast< ::GoBang::UndoRequest&>(::GoBang::_UndoRequest_default_instance_);
}
inline const ::GoBang::UndoRequest& goBangRequest::undoreq() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangRequest.undoReq)
  return _internal_undoreq();
}
inline ::GoBang::UndoRequest* goBangRequest::unsafe_arena_release_undoreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangRequest.undoReq)
  if (_internal_has_undoreq()) {
    clear_has_request();
    ::GoBang::UndoRequest* temp = _impl_.request_.undoreq_;
    _impl_.request_.undoreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangRequest::unsafe_arena_set_allocated_undoreq(::GoBang::UndoRequest* undoreq) {
  clear_request();
  if (undoreq) {
    set_has_undoreq();
    _impl_.request_.undoreq_ = undoreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangRequest.undoReq)
}
inline ::GoBang::UndoRequest* goBangRequest::_internal_mutable_undoreq() {
  if (!_internal_has_undoreq()) {
    clear_request();
    set_has_undoreq();
    _impl_.request_.undoreq_ = CreateMaybeMessage< ::GoBang::UndoRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.undoreq_;
}
inline ::GoBang::UndoRequest* goBangRequest::mutable_undoreq() {
  ::GoBang::UndoRequest* _msg = _internal_mutable_undoreq();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangRequest.undoReq)
  return _msg;
}

// .GoBang.UndoResponse undoResp = 15;
inline bool goBangRequest::_internal_has_undoresp() const {
  return request_case() == kUndoResp;
}
inline bool goBangRequest::has_undoresp() const {
  return _internal_has_undoresp();
}
inline void goBangRequest::set_has_undoresp() {
  _impl_._oneof_case_[0] = kUndoResp;
}
inline void goBangRequest::clear_undoresp() {
  if (_internal_has_undoresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.undoresp_;
    }
    clear_has_request();
  }
}
inline ::GoBang::UndoResponse* goBangRequest::release_undoresp() {
  // @@protoc_insertion_point(field_release:GoBang.goBangRequest.undoResp)
  if (_internal_has_undoresp()) {
    clear_has_request();
    ::GoBang::UndoResponse* temp = _impl_.request_.undoresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.undoresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::UndoResponse& goBangRequest::_internal_undoresp() const {
  return _internal_has_undoresp()
      ? *_impl_.request_.undoresp_
      : reinterpret_cast< ::GoBang::UndoResponse&>(::GoBang::_UndoResponse_default_instance_);
}
inline const ::GoBang::UndoResponse& goBangRequest::undoresp() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangRequest.undoResp)
  return _internal_undoresp();
}
inline ::GoBang::UndoResponse* goBangRequest::unsafe_arena_release_undoresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangRequest.undoResp)
  if (_internal_has_undoresp()) {
    clear_has_request();
    ::GoBang::UndoResponse* temp = _impl_.request_.undoresp_;
    _impl_.request_.undoresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangRequest::unsafe_arena_set_allocated_undoresp(::GoBang::UndoResponse* undoresp) {
  clear_request();
  if (undoresp) {
    set_has_undoresp();
    _impl_.request_.undoresp_ = undoresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangRequest.undoResp)
}
inline ::GoBang::UndoResponse* goBangRequest::_internal_mutable_undoresp() {
  if (!_internal_has_undoresp()) {
    clear_request();
    set_has_undoresp();
    _impl_.request_.undoresp_ = CreateMaybeMessage< ::GoBang::UndoResponse >(GetArenaForAllocation());
  }
  return _impl_.request_.undoresp_;
}
inline ::GoBang::UndoResponse* goBangRequest::mutable_undoresp() {
  ::GoBang::UndoResponse* _msg = _internal_mutable_undoresp();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangRequest.undoResp)
  return _msg;
}

// .GoBang.TieRequest tieReq = 8;
inline bool goBangRequest::_internal_has_tiereq() const {
  return request_case() == kTieReq;
}
inline bool goBangRequest::has_tiereq() const {
  return _internal_has_tiereq();
}
inline void goBangRequest::set_has_tiereq() {
  _impl_._oneof_case_[0] = kTieReq;
}
inline void goBangRequest::clear_tiereq() {
  if (_internal_has_tiereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.tiereq_;
    }
    clear_has_request();
  }
}
inline ::GoBang::TieRequest* goBangRequest::release_tiereq() {
  // @@protoc_insertion_point(field_release:GoBang.goBangRequest.tieReq)
  if (_internal_has_tiereq()) {
    clear_has_request();
    ::GoBang::TieRequest* temp = _impl_.request_.tiereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.tiereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::TieRequest& goBangRequest::_internal_tiereq() const {
  return _internal_has_tiereq()
      ? *_impl_.request_.tiereq_
      : reinterpret_cast< ::GoBang::TieRequest&>(::GoBang::_TieRequest_default_instance_);
}
inline const ::GoBang::TieRequest& goBangRequest::tiereq() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangRequest.tieReq)
  return _internal_tiereq();
}
inline ::GoBang::TieRequest* goBangRequest::unsafe_arena_release_tiereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangRequest.tieReq)
  if (_internal_has_tiereq()) {
    clear_has_request();
    ::GoBang::TieRequest* temp = _impl_.request_.tiereq_;
    _impl_.request_.tiereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangRequest::unsafe_arena_set_allocated_tiereq(::GoBang::TieRequest* tiereq) {
  clear_request();
  if (tiereq) {
    set_has_tiereq();
    _impl_.request_.tiereq_ = tiereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangRequest.tieReq)
}
inline ::GoBang::TieRequest* goBangRequest::_internal_mutable_tiereq() {
  if (!_internal_has_tiereq()) {
    clear_request();
    set_has_tiereq();
    _impl_.request_.tiereq_ = CreateMaybeMessage< ::GoBang::TieRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.tiereq_;
}
inline ::GoBang::TieRequest* goBangRequest::mutable_tiereq() {
  ::GoBang::TieRequest* _msg = _internal_mutable_tiereq();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangRequest.tieReq)
  return _msg;
}

// .GoBang.TieResponse tieResp = 14;
inline bool goBangRequest::_internal_has_tieresp() const {
  return request_case() == kTieResp;
}
inline bool goBangRequest::has_tieresp() const {
  return _internal_has_tieresp();
}
inline void goBangRequest::set_has_tieresp() {
  _impl_._oneof_case_[0] = kTieResp;
}
inline void goBangRequest::clear_tieresp() {
  if (_internal_has_tieresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.tieresp_;
    }
    clear_has_request();
  }
}
inline ::GoBang::TieResponse* goBangRequest::release_tieresp() {
  // @@protoc_insertion_point(field_release:GoBang.goBangRequest.tieResp)
  if (_internal_has_tieresp()) {
    clear_has_request();
    ::GoBang::TieResponse* temp = _impl_.request_.tieresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.tieresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::TieResponse& goBangRequest::_internal_tieresp() const {
  return _internal_has_tieresp()
      ? *_impl_.request_.tieresp_
      : reinterpret_cast< ::GoBang::TieResponse&>(::GoBang::_TieResponse_default_instance_);
}
inline const ::GoBang::TieResponse& goBangRequest::tieresp() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangRequest.tieResp)
  return _internal_tieresp();
}
inline ::GoBang::TieResponse* goBangRequest::unsafe_arena_release_tieresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangRequest.tieResp)
  if (_internal_has_tieresp()) {
    clear_has_request();
    ::GoBang::TieResponse* temp = _impl_.request_.tieresp_;
    _impl_.request_.tieresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangRequest::unsafe_arena_set_allocated_tieresp(::GoBang::TieResponse* tieresp) {
  clear_request();
  if (tieresp) {
    set_has_tieresp();
    _impl_.request_.tieresp_ = tieresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangRequest.tieResp)
}
inline ::GoBang::TieResponse* goBangRequest::_internal_mutable_tieresp() {
  if (!_internal_has_tieresp()) {
    clear_request();
    set_has_tieresp();
    _impl_.request_.tieresp_ = CreateMaybeMessage< ::GoBang::TieResponse >(GetArenaForAllocation());
  }
  return _impl_.request_.tieresp_;
}
inline ::GoBang::TieResponse* goBangRequest::mutable_tieresp() {
  ::GoBang::TieResponse* _msg = _internal_mutable_tieresp();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangRequest.tieResp)
  return _msg;
}

// .GoBang.SurrenderRequest surrenderReq = 9;
inline bool goBangRequest::_internal_has_surrenderreq() const {
  return request_case() == kSurrenderReq;
}
inline bool goBangRequest::has_surrenderreq() const {
  return _internal_has_surrenderreq();
}
inline void goBangRequest::set_has_surrenderreq() {
  _impl_._oneof_case_[0] = kSurrenderReq;
}
inline void goBangRequest::clear_surrenderreq() {
  if (_internal_has_surrenderreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.surrenderreq_;
    }
    clear_has_request();
  }
}
inline ::GoBang::SurrenderRequest* goBangRequest::release_surrenderreq() {
  // @@protoc_insertion_point(field_release:GoBang.goBangRequest.surrenderReq)
  if (_internal_has_surrenderreq()) {
    clear_has_request();
    ::GoBang::SurrenderRequest* temp = _impl_.request_.surrenderreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.surrenderreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::SurrenderRequest& goBangRequest::_internal_surrenderreq() const {
  return _internal_has_surrenderreq()
      ? *_impl_.request_.surrenderreq_
      : reinterpret_cast< ::GoBang::SurrenderRequest&>(::GoBang::_SurrenderRequest_default_instance_);
}
inline const ::GoBang::SurrenderRequest& goBangRequest::surrenderreq() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangRequest.surrenderReq)
  return _internal_surrenderreq();
}
inline ::GoBang::SurrenderRequest* goBangRequest::unsafe_arena_release_surrenderreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangRequest.surrenderReq)
  if (_internal_has_surrenderreq()) {
    clear_has_request();
    ::GoBang::SurrenderRequest* temp = _impl_.request_.surrenderreq_;
    _impl_.request_.surrenderreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangRequest::unsafe_arena_set_allocated_surrenderreq(::GoBang::SurrenderRequest* surrenderreq) {
  clear_request();
  if (surrenderreq) {
    set_has_surrenderreq();
    _impl_.request_.surrenderreq_ = surrenderreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangRequest.surrenderReq)
}
inline ::GoBang::SurrenderRequest* goBangRequest::_internal_mutable_surrenderreq() {
  if (!_internal_has_surrenderreq()) {
    clear_request();
    set_has_surrenderreq();
    _impl_.request_.surrenderreq_ = CreateMaybeMessage< ::GoBang::SurrenderRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.surrenderreq_;
}
inline ::GoBang::SurrenderRequest* goBangRequest::mutable_surrenderreq() {
  ::GoBang::SurrenderRequest* _msg = _internal_mutable_surrenderreq();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangRequest.surrenderReq)
  return _msg;
}

// .GoBang.Messg messg = 10;
inline bool goBangRequest::_internal_has_messg() const {
  return request_case() == kMessg;
}
inline bool goBangRequest::has_messg() const {
  return _internal_has_messg();
}
inline void goBangRequest::set_has_messg() {
  _impl_._oneof_case_[0] = kMessg;
}
inline void goBangRequest::clear_messg() {
  if (_internal_has_messg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.messg_;
    }
    clear_has_request();
  }
}
inline ::GoBang::Messg* goBangRequest::release_messg() {
  // @@protoc_insertion_point(field_release:GoBang.goBangRequest.messg)
  if (_internal_has_messg()) {
    clear_has_request();
    ::GoBang::Messg* temp = _impl_.request_.messg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.messg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::Messg& goBangRequest::_internal_messg() const {
  return _internal_has_messg()
      ? *_impl_.request_.messg_
      : reinterpret_cast< ::GoBang::Messg&>(::GoBang::_Messg_default_instance_);
}
inline const ::GoBang::Messg& goBangRequest::messg() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangRequest.messg)
  return _internal_messg();
}
inline ::GoBang::Messg* goBangRequest::unsafe_arena_release_messg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangRequest.messg)
  if (_internal_has_messg()) {
    clear_has_request();
    ::GoBang::Messg* temp = _impl_.request_.messg_;
    _impl_.request_.messg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangRequest::unsafe_arena_set_allocated_messg(::GoBang::Messg* messg) {
  clear_request();
  if (messg) {
    set_has_messg();
    _impl_.request_.messg_ = messg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangRequest.messg)
}
inline ::GoBang::Messg* goBangRequest::_internal_mutable_messg() {
  if (!_internal_has_messg()) {
    clear_request();
    set_has_messg();
    _impl_.request_.messg_ = CreateMaybeMessage< ::GoBang::Messg >(GetArenaForAllocation());
  }
  return _impl_.request_.messg_;
}
inline ::GoBang::Messg* goBangRequest::mutable_messg() {
  ::GoBang::Messg* _msg = _internal_mutable_messg();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangRequest.messg)
  return _msg;
}

// .GoBang.ContinueGameRequest continueGameReq = 11;
inline bool goBangRequest::_internal_has_continuegamereq() const {
  return request_case() == kContinueGameReq;
}
inline bool goBangRequest::has_continuegamereq() const {
  return _internal_has_continuegamereq();
}
inline void goBangRequest::set_has_continuegamereq() {
  _impl_._oneof_case_[0] = kContinueGameReq;
}
inline void goBangRequest::clear_continuegamereq() {
  if (_internal_has_continuegamereq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.continuegamereq_;
    }
    clear_has_request();
  }
}
inline ::GoBang::ContinueGameRequest* goBangRequest::release_continuegamereq() {
  // @@protoc_insertion_point(field_release:GoBang.goBangRequest.continueGameReq)
  if (_internal_has_continuegamereq()) {
    clear_has_request();
    ::GoBang::ContinueGameRequest* temp = _impl_.request_.continuegamereq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.continuegamereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::ContinueGameRequest& goBangRequest::_internal_continuegamereq() const {
  return _internal_has_continuegamereq()
      ? *_impl_.request_.continuegamereq_
      : reinterpret_cast< ::GoBang::ContinueGameRequest&>(::GoBang::_ContinueGameRequest_default_instance_);
}
inline const ::GoBang::ContinueGameRequest& goBangRequest::continuegamereq() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangRequest.continueGameReq)
  return _internal_continuegamereq();
}
inline ::GoBang::ContinueGameRequest* goBangRequest::unsafe_arena_release_continuegamereq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangRequest.continueGameReq)
  if (_internal_has_continuegamereq()) {
    clear_has_request();
    ::GoBang::ContinueGameRequest* temp = _impl_.request_.continuegamereq_;
    _impl_.request_.continuegamereq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangRequest::unsafe_arena_set_allocated_continuegamereq(::GoBang::ContinueGameRequest* continuegamereq) {
  clear_request();
  if (continuegamereq) {
    set_has_continuegamereq();
    _impl_.request_.continuegamereq_ = continuegamereq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangRequest.continueGameReq)
}
inline ::GoBang::ContinueGameRequest* goBangRequest::_internal_mutable_continuegamereq() {
  if (!_internal_has_continuegamereq()) {
    clear_request();
    set_has_continuegamereq();
    _impl_.request_.continuegamereq_ = CreateMaybeMessage< ::GoBang::ContinueGameRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.continuegamereq_;
}
inline ::GoBang::ContinueGameRequest* goBangRequest::mutable_continuegamereq() {
  ::GoBang::ContinueGameRequest* _msg = _internal_mutable_continuegamereq();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangRequest.continueGameReq)
  return _msg;
}

// .GoBang.QuitRoomRequest quitRoomReq = 12;
inline bool goBangRequest::_internal_has_quitroomreq() const {
  return request_case() == kQuitRoomReq;
}
inline bool goBangRequest::has_quitroomreq() const {
  return _internal_has_quitroomreq();
}
inline void goBangRequest::set_has_quitroomreq() {
  _impl_._oneof_case_[0] = kQuitRoomReq;
}
inline void goBangRequest::clear_quitroomreq() {
  if (_internal_has_quitroomreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.quitroomreq_;
    }
    clear_has_request();
  }
}
inline ::GoBang::QuitRoomRequest* goBangRequest::release_quitroomreq() {
  // @@protoc_insertion_point(field_release:GoBang.goBangRequest.quitRoomReq)
  if (_internal_has_quitroomreq()) {
    clear_has_request();
    ::GoBang::QuitRoomRequest* temp = _impl_.request_.quitroomreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.quitroomreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::QuitRoomRequest& goBangRequest::_internal_quitroomreq() const {
  return _internal_has_quitroomreq()
      ? *_impl_.request_.quitroomreq_
      : reinterpret_cast< ::GoBang::QuitRoomRequest&>(::GoBang::_QuitRoomRequest_default_instance_);
}
inline const ::GoBang::QuitRoomRequest& goBangRequest::quitroomreq() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangRequest.quitRoomReq)
  return _internal_quitroomreq();
}
inline ::GoBang::QuitRoomRequest* goBangRequest::unsafe_arena_release_quitroomreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangRequest.quitRoomReq)
  if (_internal_has_quitroomreq()) {
    clear_has_request();
    ::GoBang::QuitRoomRequest* temp = _impl_.request_.quitroomreq_;
    _impl_.request_.quitroomreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangRequest::unsafe_arena_set_allocated_quitroomreq(::GoBang::QuitRoomRequest* quitroomreq) {
  clear_request();
  if (quitroomreq) {
    set_has_quitroomreq();
    _impl_.request_.quitroomreq_ = quitroomreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangRequest.quitRoomReq)
}
inline ::GoBang::QuitRoomRequest* goBangRequest::_internal_mutable_quitroomreq() {
  if (!_internal_has_quitroomreq()) {
    clear_request();
    set_has_quitroomreq();
    _impl_.request_.quitroomreq_ = CreateMaybeMessage< ::GoBang::QuitRoomRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.quitroomreq_;
}
inline ::GoBang::QuitRoomRequest* goBangRequest::mutable_quitroomreq() {
  ::GoBang::QuitRoomRequest* _msg = _internal_mutable_quitroomreq();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangRequest.quitRoomReq)
  return _msg;
}

// .GoBang.NormalMatchRequest normalMatchReq = 13;
inline bool goBangRequest::_internal_has_normalmatchreq() const {
  return request_case() == kNormalMatchReq;
}
inline bool goBangRequest::has_normalmatchreq() const {
  return _internal_has_normalmatchreq();
}
inline void goBangRequest::set_has_normalmatchreq() {
  _impl_._oneof_case_[0] = kNormalMatchReq;
}
inline void goBangRequest::clear_normalmatchreq() {
  if (_internal_has_normalmatchreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.normalmatchreq_;
    }
    clear_has_request();
  }
}
inline ::GoBang::NormalMatchRequest* goBangRequest::release_normalmatchreq() {
  // @@protoc_insertion_point(field_release:GoBang.goBangRequest.normalMatchReq)
  if (_internal_has_normalmatchreq()) {
    clear_has_request();
    ::GoBang::NormalMatchRequest* temp = _impl_.request_.normalmatchreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.normalmatchreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::NormalMatchRequest& goBangRequest::_internal_normalmatchreq() const {
  return _internal_has_normalmatchreq()
      ? *_impl_.request_.normalmatchreq_
      : reinterpret_cast< ::GoBang::NormalMatchRequest&>(::GoBang::_NormalMatchRequest_default_instance_);
}
inline const ::GoBang::NormalMatchRequest& goBangRequest::normalmatchreq() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangRequest.normalMatchReq)
  return _internal_normalmatchreq();
}
inline ::GoBang::NormalMatchRequest* goBangRequest::unsafe_arena_release_normalmatchreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangRequest.normalMatchReq)
  if (_internal_has_normalmatchreq()) {
    clear_has_request();
    ::GoBang::NormalMatchRequest* temp = _impl_.request_.normalmatchreq_;
    _impl_.request_.normalmatchreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangRequest::unsafe_arena_set_allocated_normalmatchreq(::GoBang::NormalMatchRequest* normalmatchreq) {
  clear_request();
  if (normalmatchreq) {
    set_has_normalmatchreq();
    _impl_.request_.normalmatchreq_ = normalmatchreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangRequest.normalMatchReq)
}
inline ::GoBang::NormalMatchRequest* goBangRequest::_internal_mutable_normalmatchreq() {
  if (!_internal_has_normalmatchreq()) {
    clear_request();
    set_has_normalmatchreq();
    _impl_.request_.normalmatchreq_ = CreateMaybeMessage< ::GoBang::NormalMatchRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.normalmatchreq_;
}
inline ::GoBang::NormalMatchRequest* goBangRequest::mutable_normalmatchreq() {
  ::GoBang::NormalMatchRequest* _msg = _internal_mutable_normalmatchreq();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangRequest.normalMatchReq)
  return _msg;
}

// .GoBang.RankMatchRequest rankMatchReq = 16;
inline bool goBangRequest::_internal_has_rankmatchreq() const {
  return request_case() == kRankMatchReq;
}
inline bool goBangRequest::has_rankmatchreq() const {
  return _internal_has_rankmatchreq();
}
inline void goBangRequest::set_has_rankmatchreq() {
  _impl_._oneof_case_[0] = kRankMatchReq;
}
inline void goBangRequest::clear_rankmatchreq() {
  if (_internal_has_rankmatchreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_.rankmatchreq_;
    }
    clear_has_request();
  }
}
inline ::GoBang::RankMatchRequest* goBangRequest::release_rankmatchreq() {
  // @@protoc_insertion_point(field_release:GoBang.goBangRequest.rankMatchReq)
  if (_internal_has_rankmatchreq()) {
    clear_has_request();
    ::GoBang::RankMatchRequest* temp = _impl_.request_.rankmatchreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_.rankmatchreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::RankMatchRequest& goBangRequest::_internal_rankmatchreq() const {
  return _internal_has_rankmatchreq()
      ? *_impl_.request_.rankmatchreq_
      : reinterpret_cast< ::GoBang::RankMatchRequest&>(::GoBang::_RankMatchRequest_default_instance_);
}
inline const ::GoBang::RankMatchRequest& goBangRequest::rankmatchreq() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangRequest.rankMatchReq)
  return _internal_rankmatchreq();
}
inline ::GoBang::RankMatchRequest* goBangRequest::unsafe_arena_release_rankmatchreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangRequest.rankMatchReq)
  if (_internal_has_rankmatchreq()) {
    clear_has_request();
    ::GoBang::RankMatchRequest* temp = _impl_.request_.rankmatchreq_;
    _impl_.request_.rankmatchreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangRequest::unsafe_arena_set_allocated_rankmatchreq(::GoBang::RankMatchRequest* rankmatchreq) {
  clear_request();
  if (rankmatchreq) {
    set_has_rankmatchreq();
    _impl_.request_.rankmatchreq_ = rankmatchreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangRequest.rankMatchReq)
}
inline ::GoBang::RankMatchRequest* goBangRequest::_internal_mutable_rankmatchreq() {
  if (!_internal_has_rankmatchreq()) {
    clear_request();
    set_has_rankmatchreq();
    _impl_.request_.rankmatchreq_ = CreateMaybeMessage< ::GoBang::RankMatchRequest >(GetArenaForAllocation());
  }
  return _impl_.request_.rankmatchreq_;
}
inline ::GoBang::RankMatchRequest* goBangRequest::mutable_rankmatchreq() {
  ::GoBang::RankMatchRequest* _msg = _internal_mutable_rankmatchreq();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangRequest.rankMatchReq)
  return _msg;
}

inline bool goBangRequest::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void goBangRequest::clear_has_request() {
  _impl_._oneof_case_[0] = REQUEST_NOT_SET;
}
inline goBangRequest::RequestCase goBangRequest::request_case() const {
  return goBangRequest::RequestCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// goBangResponse

// .GoBang.TYPE type = 1;
inline void goBangResponse::clear_type() {
  _impl_.type_ = 0;
}
inline ::GoBang::TYPE goBangResponse::_internal_type() const {
  return static_cast< ::GoBang::TYPE >(_impl_.type_);
}
inline ::GoBang::TYPE goBangResponse::type() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangResponse.type)
  return _internal_type();
}
inline void goBangResponse::_internal_set_type(::GoBang::TYPE value) {
  
  _impl_.type_ = value;
}
inline void goBangResponse::set_type(::GoBang::TYPE value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:GoBang.goBangResponse.type)
}

// .GoBang.LoginResponse loginResp = 2;
inline bool goBangResponse::_internal_has_loginresp() const {
  return response_case() == kLoginResp;
}
inline bool goBangResponse::has_loginresp() const {
  return _internal_has_loginresp();
}
inline void goBangResponse::set_has_loginresp() {
  _impl_._oneof_case_[0] = kLoginResp;
}
inline void goBangResponse::clear_loginresp() {
  if (_internal_has_loginresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.loginresp_;
    }
    clear_has_response();
  }
}
inline ::GoBang::LoginResponse* goBangResponse::release_loginresp() {
  // @@protoc_insertion_point(field_release:GoBang.goBangResponse.loginResp)
  if (_internal_has_loginresp()) {
    clear_has_response();
    ::GoBang::LoginResponse* temp = _impl_.response_.loginresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.loginresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::LoginResponse& goBangResponse::_internal_loginresp() const {
  return _internal_has_loginresp()
      ? *_impl_.response_.loginresp_
      : reinterpret_cast< ::GoBang::LoginResponse&>(::GoBang::_LoginResponse_default_instance_);
}
inline const ::GoBang::LoginResponse& goBangResponse::loginresp() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangResponse.loginResp)
  return _internal_loginresp();
}
inline ::GoBang::LoginResponse* goBangResponse::unsafe_arena_release_loginresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangResponse.loginResp)
  if (_internal_has_loginresp()) {
    clear_has_response();
    ::GoBang::LoginResponse* temp = _impl_.response_.loginresp_;
    _impl_.response_.loginresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangResponse::unsafe_arena_set_allocated_loginresp(::GoBang::LoginResponse* loginresp) {
  clear_response();
  if (loginresp) {
    set_has_loginresp();
    _impl_.response_.loginresp_ = loginresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangResponse.loginResp)
}
inline ::GoBang::LoginResponse* goBangResponse::_internal_mutable_loginresp() {
  if (!_internal_has_loginresp()) {
    clear_response();
    set_has_loginresp();
    _impl_.response_.loginresp_ = CreateMaybeMessage< ::GoBang::LoginResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.loginresp_;
}
inline ::GoBang::LoginResponse* goBangResponse::mutable_loginresp() {
  ::GoBang::LoginResponse* _msg = _internal_mutable_loginresp();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangResponse.loginResp)
  return _msg;
}

// .GoBang.RegisterResponse registerResp = 3;
inline bool goBangResponse::_internal_has_registerresp() const {
  return response_case() == kRegisterResp;
}
inline bool goBangResponse::has_registerresp() const {
  return _internal_has_registerresp();
}
inline void goBangResponse::set_has_registerresp() {
  _impl_._oneof_case_[0] = kRegisterResp;
}
inline void goBangResponse::clear_registerresp() {
  if (_internal_has_registerresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.registerresp_;
    }
    clear_has_response();
  }
}
inline ::GoBang::RegisterResponse* goBangResponse::release_registerresp() {
  // @@protoc_insertion_point(field_release:GoBang.goBangResponse.registerResp)
  if (_internal_has_registerresp()) {
    clear_has_response();
    ::GoBang::RegisterResponse* temp = _impl_.response_.registerresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.registerresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::RegisterResponse& goBangResponse::_internal_registerresp() const {
  return _internal_has_registerresp()
      ? *_impl_.response_.registerresp_
      : reinterpret_cast< ::GoBang::RegisterResponse&>(::GoBang::_RegisterResponse_default_instance_);
}
inline const ::GoBang::RegisterResponse& goBangResponse::registerresp() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangResponse.registerResp)
  return _internal_registerresp();
}
inline ::GoBang::RegisterResponse* goBangResponse::unsafe_arena_release_registerresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangResponse.registerResp)
  if (_internal_has_registerresp()) {
    clear_has_response();
    ::GoBang::RegisterResponse* temp = _impl_.response_.registerresp_;
    _impl_.response_.registerresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangResponse::unsafe_arena_set_allocated_registerresp(::GoBang::RegisterResponse* registerresp) {
  clear_response();
  if (registerresp) {
    set_has_registerresp();
    _impl_.response_.registerresp_ = registerresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangResponse.registerResp)
}
inline ::GoBang::RegisterResponse* goBangResponse::_internal_mutable_registerresp() {
  if (!_internal_has_registerresp()) {
    clear_response();
    set_has_registerresp();
    _impl_.response_.registerresp_ = CreateMaybeMessage< ::GoBang::RegisterResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.registerresp_;
}
inline ::GoBang::RegisterResponse* goBangResponse::mutable_registerresp() {
  ::GoBang::RegisterResponse* _msg = _internal_mutable_registerresp();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangResponse.registerResp)
  return _msg;
}

// .GoBang.RankListResponse rankListResp = 4;
inline bool goBangResponse::_internal_has_ranklistresp() const {
  return response_case() == kRankListResp;
}
inline bool goBangResponse::has_ranklistresp() const {
  return _internal_has_ranklistresp();
}
inline void goBangResponse::set_has_ranklistresp() {
  _impl_._oneof_case_[0] = kRankListResp;
}
inline void goBangResponse::clear_ranklistresp() {
  if (_internal_has_ranklistresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.ranklistresp_;
    }
    clear_has_response();
  }
}
inline ::GoBang::RankListResponse* goBangResponse::release_ranklistresp() {
  // @@protoc_insertion_point(field_release:GoBang.goBangResponse.rankListResp)
  if (_internal_has_ranklistresp()) {
    clear_has_response();
    ::GoBang::RankListResponse* temp = _impl_.response_.ranklistresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.ranklistresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::RankListResponse& goBangResponse::_internal_ranklistresp() const {
  return _internal_has_ranklistresp()
      ? *_impl_.response_.ranklistresp_
      : reinterpret_cast< ::GoBang::RankListResponse&>(::GoBang::_RankListResponse_default_instance_);
}
inline const ::GoBang::RankListResponse& goBangResponse::ranklistresp() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangResponse.rankListResp)
  return _internal_ranklistresp();
}
inline ::GoBang::RankListResponse* goBangResponse::unsafe_arena_release_ranklistresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangResponse.rankListResp)
  if (_internal_has_ranklistresp()) {
    clear_has_response();
    ::GoBang::RankListResponse* temp = _impl_.response_.ranklistresp_;
    _impl_.response_.ranklistresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangResponse::unsafe_arena_set_allocated_ranklistresp(::GoBang::RankListResponse* ranklistresp) {
  clear_response();
  if (ranklistresp) {
    set_has_ranklistresp();
    _impl_.response_.ranklistresp_ = ranklistresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangResponse.rankListResp)
}
inline ::GoBang::RankListResponse* goBangResponse::_internal_mutable_ranklistresp() {
  if (!_internal_has_ranklistresp()) {
    clear_response();
    set_has_ranklistresp();
    _impl_.response_.ranklistresp_ = CreateMaybeMessage< ::GoBang::RankListResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.ranklistresp_;
}
inline ::GoBang::RankListResponse* goBangResponse::mutable_ranklistresp() {
  ::GoBang::RankListResponse* _msg = _internal_mutable_ranklistresp();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangResponse.rankListResp)
  return _msg;
}

// .GoBang.CreateRoomResponse createRoomResp = 5;
inline bool goBangResponse::_internal_has_createroomresp() const {
  return response_case() == kCreateRoomResp;
}
inline bool goBangResponse::has_createroomresp() const {
  return _internal_has_createroomresp();
}
inline void goBangResponse::set_has_createroomresp() {
  _impl_._oneof_case_[0] = kCreateRoomResp;
}
inline void goBangResponse::clear_createroomresp() {
  if (_internal_has_createroomresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.createroomresp_;
    }
    clear_has_response();
  }
}
inline ::GoBang::CreateRoomResponse* goBangResponse::release_createroomresp() {
  // @@protoc_insertion_point(field_release:GoBang.goBangResponse.createRoomResp)
  if (_internal_has_createroomresp()) {
    clear_has_response();
    ::GoBang::CreateRoomResponse* temp = _impl_.response_.createroomresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.createroomresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::CreateRoomResponse& goBangResponse::_internal_createroomresp() const {
  return _internal_has_createroomresp()
      ? *_impl_.response_.createroomresp_
      : reinterpret_cast< ::GoBang::CreateRoomResponse&>(::GoBang::_CreateRoomResponse_default_instance_);
}
inline const ::GoBang::CreateRoomResponse& goBangResponse::createroomresp() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangResponse.createRoomResp)
  return _internal_createroomresp();
}
inline ::GoBang::CreateRoomResponse* goBangResponse::unsafe_arena_release_createroomresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangResponse.createRoomResp)
  if (_internal_has_createroomresp()) {
    clear_has_response();
    ::GoBang::CreateRoomResponse* temp = _impl_.response_.createroomresp_;
    _impl_.response_.createroomresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangResponse::unsafe_arena_set_allocated_createroomresp(::GoBang::CreateRoomResponse* createroomresp) {
  clear_response();
  if (createroomresp) {
    set_has_createroomresp();
    _impl_.response_.createroomresp_ = createroomresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangResponse.createRoomResp)
}
inline ::GoBang::CreateRoomResponse* goBangResponse::_internal_mutable_createroomresp() {
  if (!_internal_has_createroomresp()) {
    clear_response();
    set_has_createroomresp();
    _impl_.response_.createroomresp_ = CreateMaybeMessage< ::GoBang::CreateRoomResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.createroomresp_;
}
inline ::GoBang::CreateRoomResponse* goBangResponse::mutable_createroomresp() {
  ::GoBang::CreateRoomResponse* _msg = _internal_mutable_createroomresp();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangResponse.createRoomResp)
  return _msg;
}

// .GoBang.SetPieceResponse setPieceResp = 6;
inline bool goBangResponse::_internal_has_setpieceresp() const {
  return response_case() == kSetPieceResp;
}
inline bool goBangResponse::has_setpieceresp() const {
  return _internal_has_setpieceresp();
}
inline void goBangResponse::set_has_setpieceresp() {
  _impl_._oneof_case_[0] = kSetPieceResp;
}
inline void goBangResponse::clear_setpieceresp() {
  if (_internal_has_setpieceresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.setpieceresp_;
    }
    clear_has_response();
  }
}
inline ::GoBang::SetPieceResponse* goBangResponse::release_setpieceresp() {
  // @@protoc_insertion_point(field_release:GoBang.goBangResponse.setPieceResp)
  if (_internal_has_setpieceresp()) {
    clear_has_response();
    ::GoBang::SetPieceResponse* temp = _impl_.response_.setpieceresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.setpieceresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::SetPieceResponse& goBangResponse::_internal_setpieceresp() const {
  return _internal_has_setpieceresp()
      ? *_impl_.response_.setpieceresp_
      : reinterpret_cast< ::GoBang::SetPieceResponse&>(::GoBang::_SetPieceResponse_default_instance_);
}
inline const ::GoBang::SetPieceResponse& goBangResponse::setpieceresp() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangResponse.setPieceResp)
  return _internal_setpieceresp();
}
inline ::GoBang::SetPieceResponse* goBangResponse::unsafe_arena_release_setpieceresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangResponse.setPieceResp)
  if (_internal_has_setpieceresp()) {
    clear_has_response();
    ::GoBang::SetPieceResponse* temp = _impl_.response_.setpieceresp_;
    _impl_.response_.setpieceresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangResponse::unsafe_arena_set_allocated_setpieceresp(::GoBang::SetPieceResponse* setpieceresp) {
  clear_response();
  if (setpieceresp) {
    set_has_setpieceresp();
    _impl_.response_.setpieceresp_ = setpieceresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangResponse.setPieceResp)
}
inline ::GoBang::SetPieceResponse* goBangResponse::_internal_mutable_setpieceresp() {
  if (!_internal_has_setpieceresp()) {
    clear_response();
    set_has_setpieceresp();
    _impl_.response_.setpieceresp_ = CreateMaybeMessage< ::GoBang::SetPieceResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.setpieceresp_;
}
inline ::GoBang::SetPieceResponse* goBangResponse::mutable_setpieceresp() {
  ::GoBang::SetPieceResponse* _msg = _internal_mutable_setpieceresp();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangResponse.setPieceResp)
  return _msg;
}

// .GoBang.UndoResponse undoResponse = 7;
inline bool goBangResponse::_internal_has_undoresponse() const {
  return response_case() == kUndoResponse;
}
inline bool goBangResponse::has_undoresponse() const {
  return _internal_has_undoresponse();
}
inline void goBangResponse::set_has_undoresponse() {
  _impl_._oneof_case_[0] = kUndoResponse;
}
inline void goBangResponse::clear_undoresponse() {
  if (_internal_has_undoresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.undoresponse_;
    }
    clear_has_response();
  }
}
inline ::GoBang::UndoResponse* goBangResponse::release_undoresponse() {
  // @@protoc_insertion_point(field_release:GoBang.goBangResponse.undoResponse)
  if (_internal_has_undoresponse()) {
    clear_has_response();
    ::GoBang::UndoResponse* temp = _impl_.response_.undoresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.undoresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::UndoResponse& goBangResponse::_internal_undoresponse() const {
  return _internal_has_undoresponse()
      ? *_impl_.response_.undoresponse_
      : reinterpret_cast< ::GoBang::UndoResponse&>(::GoBang::_UndoResponse_default_instance_);
}
inline const ::GoBang::UndoResponse& goBangResponse::undoresponse() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangResponse.undoResponse)
  return _internal_undoresponse();
}
inline ::GoBang::UndoResponse* goBangResponse::unsafe_arena_release_undoresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangResponse.undoResponse)
  if (_internal_has_undoresponse()) {
    clear_has_response();
    ::GoBang::UndoResponse* temp = _impl_.response_.undoresponse_;
    _impl_.response_.undoresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangResponse::unsafe_arena_set_allocated_undoresponse(::GoBang::UndoResponse* undoresponse) {
  clear_response();
  if (undoresponse) {
    set_has_undoresponse();
    _impl_.response_.undoresponse_ = undoresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangResponse.undoResponse)
}
inline ::GoBang::UndoResponse* goBangResponse::_internal_mutable_undoresponse() {
  if (!_internal_has_undoresponse()) {
    clear_response();
    set_has_undoresponse();
    _impl_.response_.undoresponse_ = CreateMaybeMessage< ::GoBang::UndoResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.undoresponse_;
}
inline ::GoBang::UndoResponse* goBangResponse::mutable_undoresponse() {
  ::GoBang::UndoResponse* _msg = _internal_mutable_undoresponse();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangResponse.undoResponse)
  return _msg;
}

// .GoBang.TieResponse tieResp = 8;
inline bool goBangResponse::_internal_has_tieresp() const {
  return response_case() == kTieResp;
}
inline bool goBangResponse::has_tieresp() const {
  return _internal_has_tieresp();
}
inline void goBangResponse::set_has_tieresp() {
  _impl_._oneof_case_[0] = kTieResp;
}
inline void goBangResponse::clear_tieresp() {
  if (_internal_has_tieresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.tieresp_;
    }
    clear_has_response();
  }
}
inline ::GoBang::TieResponse* goBangResponse::release_tieresp() {
  // @@protoc_insertion_point(field_release:GoBang.goBangResponse.tieResp)
  if (_internal_has_tieresp()) {
    clear_has_response();
    ::GoBang::TieResponse* temp = _impl_.response_.tieresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.tieresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::TieResponse& goBangResponse::_internal_tieresp() const {
  return _internal_has_tieresp()
      ? *_impl_.response_.tieresp_
      : reinterpret_cast< ::GoBang::TieResponse&>(::GoBang::_TieResponse_default_instance_);
}
inline const ::GoBang::TieResponse& goBangResponse::tieresp() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangResponse.tieResp)
  return _internal_tieresp();
}
inline ::GoBang::TieResponse* goBangResponse::unsafe_arena_release_tieresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangResponse.tieResp)
  if (_internal_has_tieresp()) {
    clear_has_response();
    ::GoBang::TieResponse* temp = _impl_.response_.tieresp_;
    _impl_.response_.tieresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangResponse::unsafe_arena_set_allocated_tieresp(::GoBang::TieResponse* tieresp) {
  clear_response();
  if (tieresp) {
    set_has_tieresp();
    _impl_.response_.tieresp_ = tieresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangResponse.tieResp)
}
inline ::GoBang::TieResponse* goBangResponse::_internal_mutable_tieresp() {
  if (!_internal_has_tieresp()) {
    clear_response();
    set_has_tieresp();
    _impl_.response_.tieresp_ = CreateMaybeMessage< ::GoBang::TieResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.tieresp_;
}
inline ::GoBang::TieResponse* goBangResponse::mutable_tieresp() {
  ::GoBang::TieResponse* _msg = _internal_mutable_tieresp();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangResponse.tieResp)
  return _msg;
}

// .GoBang.UndoRequest undoReq = 17;
inline bool goBangResponse::_internal_has_undoreq() const {
  return response_case() == kUndoReq;
}
inline bool goBangResponse::has_undoreq() const {
  return _internal_has_undoreq();
}
inline void goBangResponse::set_has_undoreq() {
  _impl_._oneof_case_[0] = kUndoReq;
}
inline void goBangResponse::clear_undoreq() {
  if (_internal_has_undoreq()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.undoreq_;
    }
    clear_has_response();
  }
}
inline ::GoBang::UndoRequest* goBangResponse::release_undoreq() {
  // @@protoc_insertion_point(field_release:GoBang.goBangResponse.undoReq)
  if (_internal_has_undoreq()) {
    clear_has_response();
    ::GoBang::UndoRequest* temp = _impl_.response_.undoreq_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.undoreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::UndoRequest& goBangResponse::_internal_undoreq() const {
  return _internal_has_undoreq()
      ? *_impl_.response_.undoreq_
      : reinterpret_cast< ::GoBang::UndoRequest&>(::GoBang::_UndoRequest_default_instance_);
}
inline const ::GoBang::UndoRequest& goBangResponse::undoreq() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangResponse.undoReq)
  return _internal_undoreq();
}
inline ::GoBang::UndoRequest* goBangResponse::unsafe_arena_release_undoreq() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangResponse.undoReq)
  if (_internal_has_undoreq()) {
    clear_has_response();
    ::GoBang::UndoRequest* temp = _impl_.response_.undoreq_;
    _impl_.response_.undoreq_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangResponse::unsafe_arena_set_allocated_undoreq(::GoBang::UndoRequest* undoreq) {
  clear_response();
  if (undoreq) {
    set_has_undoreq();
    _impl_.response_.undoreq_ = undoreq;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangResponse.undoReq)
}
inline ::GoBang::UndoRequest* goBangResponse::_internal_mutable_undoreq() {
  if (!_internal_has_undoreq()) {
    clear_response();
    set_has_undoreq();
    _impl_.response_.undoreq_ = CreateMaybeMessage< ::GoBang::UndoRequest >(GetArenaForAllocation());
  }
  return _impl_.response_.undoreq_;
}
inline ::GoBang::UndoRequest* goBangResponse::mutable_undoreq() {
  ::GoBang::UndoRequest* _msg = _internal_mutable_undoreq();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangResponse.undoReq)
  return _msg;
}

// .GoBang.UndoResponse undoResp = 18;
inline bool goBangResponse::_internal_has_undoresp() const {
  return response_case() == kUndoResp;
}
inline bool goBangResponse::has_undoresp() const {
  return _internal_has_undoresp();
}
inline void goBangResponse::set_has_undoresp() {
  _impl_._oneof_case_[0] = kUndoResp;
}
inline void goBangResponse::clear_undoresp() {
  if (_internal_has_undoresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.undoresp_;
    }
    clear_has_response();
  }
}
inline ::GoBang::UndoResponse* goBangResponse::release_undoresp() {
  // @@protoc_insertion_point(field_release:GoBang.goBangResponse.undoResp)
  if (_internal_has_undoresp()) {
    clear_has_response();
    ::GoBang::UndoResponse* temp = _impl_.response_.undoresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.undoresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::UndoResponse& goBangResponse::_internal_undoresp() const {
  return _internal_has_undoresp()
      ? *_impl_.response_.undoresp_
      : reinterpret_cast< ::GoBang::UndoResponse&>(::GoBang::_UndoResponse_default_instance_);
}
inline const ::GoBang::UndoResponse& goBangResponse::undoresp() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangResponse.undoResp)
  return _internal_undoresp();
}
inline ::GoBang::UndoResponse* goBangResponse::unsafe_arena_release_undoresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangResponse.undoResp)
  if (_internal_has_undoresp()) {
    clear_has_response();
    ::GoBang::UndoResponse* temp = _impl_.response_.undoresp_;
    _impl_.response_.undoresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangResponse::unsafe_arena_set_allocated_undoresp(::GoBang::UndoResponse* undoresp) {
  clear_response();
  if (undoresp) {
    set_has_undoresp();
    _impl_.response_.undoresp_ = undoresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangResponse.undoResp)
}
inline ::GoBang::UndoResponse* goBangResponse::_internal_mutable_undoresp() {
  if (!_internal_has_undoresp()) {
    clear_response();
    set_has_undoresp();
    _impl_.response_.undoresp_ = CreateMaybeMessage< ::GoBang::UndoResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.undoresp_;
}
inline ::GoBang::UndoResponse* goBangResponse::mutable_undoresp() {
  ::GoBang::UndoResponse* _msg = _internal_mutable_undoresp();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangResponse.undoResp)
  return _msg;
}

// .GoBang.Messg messg = 10;
inline bool goBangResponse::_internal_has_messg() const {
  return response_case() == kMessg;
}
inline bool goBangResponse::has_messg() const {
  return _internal_has_messg();
}
inline void goBangResponse::set_has_messg() {
  _impl_._oneof_case_[0] = kMessg;
}
inline void goBangResponse::clear_messg() {
  if (_internal_has_messg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.messg_;
    }
    clear_has_response();
  }
}
inline ::GoBang::Messg* goBangResponse::release_messg() {
  // @@protoc_insertion_point(field_release:GoBang.goBangResponse.messg)
  if (_internal_has_messg()) {
    clear_has_response();
    ::GoBang::Messg* temp = _impl_.response_.messg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.messg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::Messg& goBangResponse::_internal_messg() const {
  return _internal_has_messg()
      ? *_impl_.response_.messg_
      : reinterpret_cast< ::GoBang::Messg&>(::GoBang::_Messg_default_instance_);
}
inline const ::GoBang::Messg& goBangResponse::messg() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangResponse.messg)
  return _internal_messg();
}
inline ::GoBang::Messg* goBangResponse::unsafe_arena_release_messg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangResponse.messg)
  if (_internal_has_messg()) {
    clear_has_response();
    ::GoBang::Messg* temp = _impl_.response_.messg_;
    _impl_.response_.messg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangResponse::unsafe_arena_set_allocated_messg(::GoBang::Messg* messg) {
  clear_response();
  if (messg) {
    set_has_messg();
    _impl_.response_.messg_ = messg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangResponse.messg)
}
inline ::GoBang::Messg* goBangResponse::_internal_mutable_messg() {
  if (!_internal_has_messg()) {
    clear_response();
    set_has_messg();
    _impl_.response_.messg_ = CreateMaybeMessage< ::GoBang::Messg >(GetArenaForAllocation());
  }
  return _impl_.response_.messg_;
}
inline ::GoBang::Messg* goBangResponse::mutable_messg() {
  ::GoBang::Messg* _msg = _internal_mutable_messg();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangResponse.messg)
  return _msg;
}

// .GoBang.ContinueGameResponse continueGameResp = 11;
inline bool goBangResponse::_internal_has_continuegameresp() const {
  return response_case() == kContinueGameResp;
}
inline bool goBangResponse::has_continuegameresp() const {
  return _internal_has_continuegameresp();
}
inline void goBangResponse::set_has_continuegameresp() {
  _impl_._oneof_case_[0] = kContinueGameResp;
}
inline void goBangResponse::clear_continuegameresp() {
  if (_internal_has_continuegameresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.continuegameresp_;
    }
    clear_has_response();
  }
}
inline ::GoBang::ContinueGameResponse* goBangResponse::release_continuegameresp() {
  // @@protoc_insertion_point(field_release:GoBang.goBangResponse.continueGameResp)
  if (_internal_has_continuegameresp()) {
    clear_has_response();
    ::GoBang::ContinueGameResponse* temp = _impl_.response_.continuegameresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.continuegameresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::ContinueGameResponse& goBangResponse::_internal_continuegameresp() const {
  return _internal_has_continuegameresp()
      ? *_impl_.response_.continuegameresp_
      : reinterpret_cast< ::GoBang::ContinueGameResponse&>(::GoBang::_ContinueGameResponse_default_instance_);
}
inline const ::GoBang::ContinueGameResponse& goBangResponse::continuegameresp() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangResponse.continueGameResp)
  return _internal_continuegameresp();
}
inline ::GoBang::ContinueGameResponse* goBangResponse::unsafe_arena_release_continuegameresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangResponse.continueGameResp)
  if (_internal_has_continuegameresp()) {
    clear_has_response();
    ::GoBang::ContinueGameResponse* temp = _impl_.response_.continuegameresp_;
    _impl_.response_.continuegameresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangResponse::unsafe_arena_set_allocated_continuegameresp(::GoBang::ContinueGameResponse* continuegameresp) {
  clear_response();
  if (continuegameresp) {
    set_has_continuegameresp();
    _impl_.response_.continuegameresp_ = continuegameresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangResponse.continueGameResp)
}
inline ::GoBang::ContinueGameResponse* goBangResponse::_internal_mutable_continuegameresp() {
  if (!_internal_has_continuegameresp()) {
    clear_response();
    set_has_continuegameresp();
    _impl_.response_.continuegameresp_ = CreateMaybeMessage< ::GoBang::ContinueGameResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.continuegameresp_;
}
inline ::GoBang::ContinueGameResponse* goBangResponse::mutable_continuegameresp() {
  ::GoBang::ContinueGameResponse* _msg = _internal_mutable_continuegameresp();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangResponse.continueGameResp)
  return _msg;
}

// .GoBang.QuitRoomResponse quitRoomResp = 12;
inline bool goBangResponse::_internal_has_quitroomresp() const {
  return response_case() == kQuitRoomResp;
}
inline bool goBangResponse::has_quitroomresp() const {
  return _internal_has_quitroomresp();
}
inline void goBangResponse::set_has_quitroomresp() {
  _impl_._oneof_case_[0] = kQuitRoomResp;
}
inline void goBangResponse::clear_quitroomresp() {
  if (_internal_has_quitroomresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.quitroomresp_;
    }
    clear_has_response();
  }
}
inline ::GoBang::QuitRoomResponse* goBangResponse::release_quitroomresp() {
  // @@protoc_insertion_point(field_release:GoBang.goBangResponse.quitRoomResp)
  if (_internal_has_quitroomresp()) {
    clear_has_response();
    ::GoBang::QuitRoomResponse* temp = _impl_.response_.quitroomresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.quitroomresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::QuitRoomResponse& goBangResponse::_internal_quitroomresp() const {
  return _internal_has_quitroomresp()
      ? *_impl_.response_.quitroomresp_
      : reinterpret_cast< ::GoBang::QuitRoomResponse&>(::GoBang::_QuitRoomResponse_default_instance_);
}
inline const ::GoBang::QuitRoomResponse& goBangResponse::quitroomresp() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangResponse.quitRoomResp)
  return _internal_quitroomresp();
}
inline ::GoBang::QuitRoomResponse* goBangResponse::unsafe_arena_release_quitroomresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangResponse.quitRoomResp)
  if (_internal_has_quitroomresp()) {
    clear_has_response();
    ::GoBang::QuitRoomResponse* temp = _impl_.response_.quitroomresp_;
    _impl_.response_.quitroomresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangResponse::unsafe_arena_set_allocated_quitroomresp(::GoBang::QuitRoomResponse* quitroomresp) {
  clear_response();
  if (quitroomresp) {
    set_has_quitroomresp();
    _impl_.response_.quitroomresp_ = quitroomresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangResponse.quitRoomResp)
}
inline ::GoBang::QuitRoomResponse* goBangResponse::_internal_mutable_quitroomresp() {
  if (!_internal_has_quitroomresp()) {
    clear_response();
    set_has_quitroomresp();
    _impl_.response_.quitroomresp_ = CreateMaybeMessage< ::GoBang::QuitRoomResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.quitroomresp_;
}
inline ::GoBang::QuitRoomResponse* goBangResponse::mutable_quitroomresp() {
  ::GoBang::QuitRoomResponse* _msg = _internal_mutable_quitroomresp();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangResponse.quitRoomResp)
  return _msg;
}

// .GoBang.GameStart gameStart = 13;
inline bool goBangResponse::_internal_has_gamestart() const {
  return response_case() == kGameStart;
}
inline bool goBangResponse::has_gamestart() const {
  return _internal_has_gamestart();
}
inline void goBangResponse::set_has_gamestart() {
  _impl_._oneof_case_[0] = kGameStart;
}
inline void goBangResponse::clear_gamestart() {
  if (_internal_has_gamestart()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.gamestart_;
    }
    clear_has_response();
  }
}
inline ::GoBang::GameStart* goBangResponse::release_gamestart() {
  // @@protoc_insertion_point(field_release:GoBang.goBangResponse.gameStart)
  if (_internal_has_gamestart()) {
    clear_has_response();
    ::GoBang::GameStart* temp = _impl_.response_.gamestart_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.gamestart_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::GameStart& goBangResponse::_internal_gamestart() const {
  return _internal_has_gamestart()
      ? *_impl_.response_.gamestart_
      : reinterpret_cast< ::GoBang::GameStart&>(::GoBang::_GameStart_default_instance_);
}
inline const ::GoBang::GameStart& goBangResponse::gamestart() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangResponse.gameStart)
  return _internal_gamestart();
}
inline ::GoBang::GameStart* goBangResponse::unsafe_arena_release_gamestart() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangResponse.gameStart)
  if (_internal_has_gamestart()) {
    clear_has_response();
    ::GoBang::GameStart* temp = _impl_.response_.gamestart_;
    _impl_.response_.gamestart_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangResponse::unsafe_arena_set_allocated_gamestart(::GoBang::GameStart* gamestart) {
  clear_response();
  if (gamestart) {
    set_has_gamestart();
    _impl_.response_.gamestart_ = gamestart;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangResponse.gameStart)
}
inline ::GoBang::GameStart* goBangResponse::_internal_mutable_gamestart() {
  if (!_internal_has_gamestart()) {
    clear_response();
    set_has_gamestart();
    _impl_.response_.gamestart_ = CreateMaybeMessage< ::GoBang::GameStart >(GetArenaForAllocation());
  }
  return _impl_.response_.gamestart_;
}
inline ::GoBang::GameStart* goBangResponse::mutable_gamestart() {
  ::GoBang::GameStart* _msg = _internal_mutable_gamestart();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangResponse.gameStart)
  return _msg;
}

// .GoBang.GameOver gameOver = 14;
inline bool goBangResponse::_internal_has_gameover() const {
  return response_case() == kGameOver;
}
inline bool goBangResponse::has_gameover() const {
  return _internal_has_gameover();
}
inline void goBangResponse::set_has_gameover() {
  _impl_._oneof_case_[0] = kGameOver;
}
inline void goBangResponse::clear_gameover() {
  if (_internal_has_gameover()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.gameover_;
    }
    clear_has_response();
  }
}
inline ::GoBang::GameOver* goBangResponse::release_gameover() {
  // @@protoc_insertion_point(field_release:GoBang.goBangResponse.gameOver)
  if (_internal_has_gameover()) {
    clear_has_response();
    ::GoBang::GameOver* temp = _impl_.response_.gameover_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.gameover_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::GameOver& goBangResponse::_internal_gameover() const {
  return _internal_has_gameover()
      ? *_impl_.response_.gameover_
      : reinterpret_cast< ::GoBang::GameOver&>(::GoBang::_GameOver_default_instance_);
}
inline const ::GoBang::GameOver& goBangResponse::gameover() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangResponse.gameOver)
  return _internal_gameover();
}
inline ::GoBang::GameOver* goBangResponse::unsafe_arena_release_gameover() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangResponse.gameOver)
  if (_internal_has_gameover()) {
    clear_has_response();
    ::GoBang::GameOver* temp = _impl_.response_.gameover_;
    _impl_.response_.gameover_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangResponse::unsafe_arena_set_allocated_gameover(::GoBang::GameOver* gameover) {
  clear_response();
  if (gameover) {
    set_has_gameover();
    _impl_.response_.gameover_ = gameover;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangResponse.gameOver)
}
inline ::GoBang::GameOver* goBangResponse::_internal_mutable_gameover() {
  if (!_internal_has_gameover()) {
    clear_response();
    set_has_gameover();
    _impl_.response_.gameover_ = CreateMaybeMessage< ::GoBang::GameOver >(GetArenaForAllocation());
  }
  return _impl_.response_.gameover_;
}
inline ::GoBang::GameOver* goBangResponse::mutable_gameover() {
  ::GoBang::GameOver* _msg = _internal_mutable_gameover();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangResponse.gameOver)
  return _msg;
}

// .GoBang.NormalMatchResponse normalMatchResp = 15;
inline bool goBangResponse::_internal_has_normalmatchresp() const {
  return response_case() == kNormalMatchResp;
}
inline bool goBangResponse::has_normalmatchresp() const {
  return _internal_has_normalmatchresp();
}
inline void goBangResponse::set_has_normalmatchresp() {
  _impl_._oneof_case_[0] = kNormalMatchResp;
}
inline void goBangResponse::clear_normalmatchresp() {
  if (_internal_has_normalmatchresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.normalmatchresp_;
    }
    clear_has_response();
  }
}
inline ::GoBang::NormalMatchResponse* goBangResponse::release_normalmatchresp() {
  // @@protoc_insertion_point(field_release:GoBang.goBangResponse.normalMatchResp)
  if (_internal_has_normalmatchresp()) {
    clear_has_response();
    ::GoBang::NormalMatchResponse* temp = _impl_.response_.normalmatchresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.normalmatchresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::NormalMatchResponse& goBangResponse::_internal_normalmatchresp() const {
  return _internal_has_normalmatchresp()
      ? *_impl_.response_.normalmatchresp_
      : reinterpret_cast< ::GoBang::NormalMatchResponse&>(::GoBang::_NormalMatchResponse_default_instance_);
}
inline const ::GoBang::NormalMatchResponse& goBangResponse::normalmatchresp() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangResponse.normalMatchResp)
  return _internal_normalmatchresp();
}
inline ::GoBang::NormalMatchResponse* goBangResponse::unsafe_arena_release_normalmatchresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangResponse.normalMatchResp)
  if (_internal_has_normalmatchresp()) {
    clear_has_response();
    ::GoBang::NormalMatchResponse* temp = _impl_.response_.normalmatchresp_;
    _impl_.response_.normalmatchresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangResponse::unsafe_arena_set_allocated_normalmatchresp(::GoBang::NormalMatchResponse* normalmatchresp) {
  clear_response();
  if (normalmatchresp) {
    set_has_normalmatchresp();
    _impl_.response_.normalmatchresp_ = normalmatchresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangResponse.normalMatchResp)
}
inline ::GoBang::NormalMatchResponse* goBangResponse::_internal_mutable_normalmatchresp() {
  if (!_internal_has_normalmatchresp()) {
    clear_response();
    set_has_normalmatchresp();
    _impl_.response_.normalmatchresp_ = CreateMaybeMessage< ::GoBang::NormalMatchResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.normalmatchresp_;
}
inline ::GoBang::NormalMatchResponse* goBangResponse::mutable_normalmatchresp() {
  ::GoBang::NormalMatchResponse* _msg = _internal_mutable_normalmatchresp();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangResponse.normalMatchResp)
  return _msg;
}

// .GoBang.RankMatchResponse rankMatchResp = 16;
inline bool goBangResponse::_internal_has_rankmatchresp() const {
  return response_case() == kRankMatchResp;
}
inline bool goBangResponse::has_rankmatchresp() const {
  return _internal_has_rankmatchresp();
}
inline void goBangResponse::set_has_rankmatchresp() {
  _impl_._oneof_case_[0] = kRankMatchResp;
}
inline void goBangResponse::clear_rankmatchresp() {
  if (_internal_has_rankmatchresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_.rankmatchresp_;
    }
    clear_has_response();
  }
}
inline ::GoBang::RankMatchResponse* goBangResponse::release_rankmatchresp() {
  // @@protoc_insertion_point(field_release:GoBang.goBangResponse.rankMatchResp)
  if (_internal_has_rankmatchresp()) {
    clear_has_response();
    ::GoBang::RankMatchResponse* temp = _impl_.response_.rankmatchresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_.rankmatchresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::GoBang::RankMatchResponse& goBangResponse::_internal_rankmatchresp() const {
  return _internal_has_rankmatchresp()
      ? *_impl_.response_.rankmatchresp_
      : reinterpret_cast< ::GoBang::RankMatchResponse&>(::GoBang::_RankMatchResponse_default_instance_);
}
inline const ::GoBang::RankMatchResponse& goBangResponse::rankmatchresp() const {
  // @@protoc_insertion_point(field_get:GoBang.goBangResponse.rankMatchResp)
  return _internal_rankmatchresp();
}
inline ::GoBang::RankMatchResponse* goBangResponse::unsafe_arena_release_rankmatchresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:GoBang.goBangResponse.rankMatchResp)
  if (_internal_has_rankmatchresp()) {
    clear_has_response();
    ::GoBang::RankMatchResponse* temp = _impl_.response_.rankmatchresp_;
    _impl_.response_.rankmatchresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void goBangResponse::unsafe_arena_set_allocated_rankmatchresp(::GoBang::RankMatchResponse* rankmatchresp) {
  clear_response();
  if (rankmatchresp) {
    set_has_rankmatchresp();
    _impl_.response_.rankmatchresp_ = rankmatchresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GoBang.goBangResponse.rankMatchResp)
}
inline ::GoBang::RankMatchResponse* goBangResponse::_internal_mutable_rankmatchresp() {
  if (!_internal_has_rankmatchresp()) {
    clear_response();
    set_has_rankmatchresp();
    _impl_.response_.rankmatchresp_ = CreateMaybeMessage< ::GoBang::RankMatchResponse >(GetArenaForAllocation());
  }
  return _impl_.response_.rankmatchresp_;
}
inline ::GoBang::RankMatchResponse* goBangResponse::mutable_rankmatchresp() {
  ::GoBang::RankMatchResponse* _msg = _internal_mutable_rankmatchresp();
  // @@protoc_insertion_point(field_mutable:GoBang.goBangResponse.rankMatchResp)
  return _msg;
}

inline bool goBangResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void goBangResponse::clear_has_response() {
  _impl_._oneof_case_[0] = RESPONSE_NOT_SET;
}
inline goBangResponse::ResponseCase goBangResponse::response_case() const {
  return goBangResponse::ResponseCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace GoBang

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::GoBang::TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GoBang::TYPE>() {
  return ::GoBang::TYPE_descriptor();
}
template <> struct is_proto_enum< ::GoBang::PieceColor> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GoBang::PieceColor>() {
  return ::GoBang::PieceColor_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_myprotocol_2eproto
